
// Author: Sam Champer and Isabel Kim.
// Created in association with Jackson Champer and the Messer lab.

// A framework for simulating many different gene drives
// with varying parameters, intended to be configured by
// alterning the heading below, or by dynamically varying
// values in the header using an associated Python file.

// The following header to be replaced via python,
// such that these values can be varied across multiple runs of slim.

//these constants may change based on cluster runs
initialize() {
	defineConstant("CAPACITY", 100000);
	defineConstant("DROP_SIZE",10000);
	defineCfgParam("EMBRYO_RESISTANCE_RATE", 1.00);
	defineCfgParam("GERMLINE_RESISTANCE_RATE", 1.00);
	defineConstant("HETEROZYGOUS_DROP", T);
	defineConstant("MALE_ONLY_DROP", F);
	defineConstant("NUM_GRNAS", 1);
	defineConstant("TADE",F);
	defineConstant("TADE_SUPPRESSION", F);
	defineConstant("TADE_DOUBLE_RESCUE",F);
	defineConstant("TARE", T);
	defineConstant("TADS_AUTOSOMAL_SUPPRESSION", F);
	defineConstant("TADS_MODIFICATION", F);
	defineConstant("R1_OCCURRENCE_RATE", 0.0);
	defineConstant("X_LINKED_DRIVE", T);
	defineConstant("ONE_DIMENSIONAL",T);
	defineConstant("BAR",0.5);
	// */    // End header.
	
	// Below are other globals.
	defineConstant("FEMALE_ONLY_DROP", F);
	defineConstant("MALE_ONLY_PROMOTER", F);
	defineConstant("NUM_CUT_PHASES", 1);
	
	// Fitness parameters:
	defineCfgParam("DD_FITNESS_VALUE", 1.00);
	defineCfgParam("DX_FITNESS_VALUE", sqrt(DD_FITNESS_VALUE));
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER_F", 1.00);
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER_M", 1.00);
	
	//Below are dimensioal sets.
	defineConstant("REPRISING_BOUNDARIES", T);
	defineConstant("DENSITY_INTERACTION_DISTANCE", 0.01);
	defineConstant("DROP_RADIUS", 0.1);
	defineConstant("SPEED", 0.04);
	defineConstant("FEMALE_SPEED", SPEED);
	defineConstant("MATING_DISTANCE", SPEED);
	defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY*DENSITY_INTERACTION_DISTANCE);
	defineCfgParam("GROWTH_AT_ZERO_DENSITY",2.0);
	
	
	
	
	// For mortality rate as a function of age:
	// Some females are allowed to survive two generations:
	defineConstant("RATE_FEMALES_SURVIVE", 0.0);
	
	// This simulation will use a non-Wright-Fisher model.
	initializeSLiMModelType("nonWF");
	
	// This simulation will take place across continuous space.
	if (ONE_DIMENSIONAL) {
		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "x"); //for 1-D
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="x", periodicity="x");
		
		initializeInteractionType(1, "x", reciprocal=T, maxDistance=MATING_DISTANCE);
		initializeInteractionType(2, "x", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	}
	i2.setInteractionFunction("l", 1.0);
	
	// Four variations: Wild type, drive, r1 resistance, r2 resistance.
	wt = initializeMutationType("m1", 0.5, "f", 0.0);
	dr = initializeMutationType("m2", 0.5, "f", 0.0);
	r1 = initializeMutationType("m3", 0.5, "f", 0.0);
	r2 = initializeMutationType("m4", 0.5, "f", 0.0);
	cut = initializeMutationType("m5", 0.5, "f", 0.0);
	gap = initializeMutationType("m6", 0.5, "f", 0.0);
	variations = c(wt, dr, r1, r2, cut, gap);
	
	// Variations are all part of g1 genome element.
	initializeGenomicElementType("g1", variations, c(1, 1, 1, 1, 1, 1));
	
	// Element is NUM_GRNAS long, each spot on the element representing a GRNA target location.
	initializeGenomicElement(g1, 0, NUM_GRNAS - 1);
	
	// These mutations overwrite one another.
	variations.mutationStackPolicy = "l";
	variations.mutationStackGroup = 1;
	
	// No mutation in this model.
	initializeRecombinationRate(0.0);
	initializeMutationRate(0.0);
	
	// Simulate sexual reproduction: A for autosome.
	initializeSex("A");
}

function (void) defineCfgParam(string$ name, lifs value) {
	if (!exists(name))
		defineConstant(name, value);
}


//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH HAPLOLETHAL STYLE SUPPRESSION.
function (logical)isHLSuppressed(o<Individual>$ ind) {
	// Check both chromosomes for the drive.	
	// Individual cannot reproduce if both chromosomes have a drive.
	if (sum(ind.genomes.countOfMutationsOfType(m2)==NUM_GRNAS)==2)
		return T;
	return F;
}


//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m3 is r1, m4 is r2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}


//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
	// Determine presence of drive in this parent.
	parent_drive_count = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If parent doesn't have drive allele, nothing happens in germline.
	if (!parent_drive_count)
		return;
	
	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(1 / (NUM_CUT_PHASES * grna_factor));
	
	// Determine if cas9 cuts the chromosome in the germline.
	casCut(child_chromosome, per_phase_cut_rate);
}


//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother) {
	// Determine presence of drive in this mother.
	mother_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If mother doesn't have drive allele, nothing happens in embryo.
	if (!mother_drive_count)
		return;
	
	// Determine the per phase cut rate.
	grna_factor = 1;
	per_phase_cut_rate = 1 - (1 - EMBRYO_RESISTANCE_RATE)^(mother_drive_count / (NUM_CUT_PHASES * grna_factor));
	
	// Then pass this rate as an argument to  the casCut funtion to
	// determine if cas9 cuts in the embryo for each chromosome.
	casCut(child_chromosome_1, per_phase_cut_rate);
	casCut(child_chromosome_2, per_phase_cut_rate);
}


//// FUNCTION FOR CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut(o<Genome>$ chromosome, f$ per_phase_cut_rate) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Vector of possible loci for cas9 to cut:
	wt_loci = chromosome.positionsOfMutationsOfType(m1);
	
	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci)) {
			// Check to see if cas9 cuts...
			if (runif(1) < per_phase_cut_rate) {
				// Convert the locus temporarily to an m5,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m5, wt_loci[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m5)) {
			cut_loci = chromosome.positionsOfMutationsOfType(m5);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m5) == 1)
				addResistanceAllele(chromosome, cut_loci[0]);
			else {
				// If multiple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m4 (R2)
				// everthing else through the rightmost site to m6 (cut).
				number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
				for (index in seqLen(number_of_cuts))
					chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
				chromosome.addNewDrawnMutation(m4, cut_loci[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites.
			if (chromosome.countOfMutationsOfType(m1) == 0)
				return;
			wt_loci = chromosome.positionsOfMutationsOfType(m1);
		}
	}
}


//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m1))) //m1 loci (wt)
		destination.addNewDrawnMutation(m1, source.positionsOfMutationsOfType(m1)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m2))) //m2 loci (dr)
		destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m3))) //m3 loci (r1)
		destination.addNewDrawnMutation(m3, source.positionsOfMutationsOfType(m3)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m4))) //m4 loci (r2)
		destination.addNewDrawnMutation(m4, source.positionsOfMutationsOfType(m4)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m5))) //m5 loci (cut)
		destination.addNewDrawnMutation(m5, source.positionsOfMutationsOfType(m5)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m6))) //m6 loci (gap)
		destination.addNewDrawnMutation(m6, source.positionsOfMutationsOfType(m6)[i]);
}



//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	// Representation of the value of the two chromosomes.
	fitness_value = 1.0;
	
	// Check both chromosomes for drive and type 2 resistance allele.
	// These are the only variants that affect fitness.
	drive_on_1 = ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS;
	drive_on_2 = ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS;
	res2_on_1 = ind.genome1.countOfMutationsOfType(m4) > 0;
	res2_on_2 = ind.genome2.countOfMutationsOfType(m4) > 0;
	wt_1 = ind.genome1.countOfMutationsOfType(m1) > 0;
	wt_2 = ind.genome2.countOfMutationsOfType(m1) > 0;
	
	somatic_fitness_mult = 1;
	if (ind.sex == "F")
		somatic_fitness_mult = SOMATIC_FITNESS_MUTLIPLIER_F;
	if (ind.sex == "M")
		somatic_fitness_mult = SOMATIC_FITNESS_MUTLIPLIER_M;
	// Check both chromosomes for the drive.
	if(ind.sex == "F"){
		if (drive_on_1) {
			fitness_value = DX_FITNESS_VALUE;
			if (wt_1 | wt_2)
				fitness_value = fitness_value * somatic_fitness_mult;
		}
		if (drive_on_2) {
			fitness_value = DX_FITNESS_VALUE;
			if (wt_1 | wt_2)
				fitness_value = fitness_value * somatic_fitness_mult;
		}
		if (drive_on_1 & drive_on_2)
			fitness_value = DD_FITNESS_VALUE;
		// Return fitness for individual with this genotype.
		return fitness_value;
	}
	if(ind.sex == "M"){
		if(drive_on_1)
			fitness_value = DD_FITNESS_VALUE;
		return fitness_value;
	}
}


//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(NULL, "F") {
	// First, evaluate whether reproduction is suppressed by a population suppression drive,
	// Then, select a mate based on fitness, then generate offspring.
	// Suppression drives:
	
	if (TADE_SUPPRESSION)
		if (isHLSuppressed(individual))
			return;
	all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
	neighbors = all_neighbors[all_neighbors.sex == "M"];
	if (size(neighbors) == 0) // If no mates are in mate detection range, the female won't mate.
		return;
	attempt_no = 0;
	while (1) {
		// First, select a random potential mate.
		mate_no = 0;
		if (size(neighbors) > 1)
			mate_no = rdunif(1, max=size(neighbors) - 1);
		selected_mate = neighbors[mate_no];
		
		// Determine attractiveness of potential mate.
		mate_attractiveness = genotypeFitness(selected_mate);
		
		// Determine if this mate is chosen, based on attractiveness and number of mates so far.
		if (runif(1) < mate_attractiveness)
			break;
		
		// After ten candidates fail, female gives up.
		attempt_no = attempt_no + 1;
		if (attempt_no == 19)
			return;
	}
	// Mate has now been selected. 	
	
	n_1 = all_neighbors[abs(all_neighbors.x - individual.x) <= DENSITY_INTERACTION_DISTANCE];
	adult_density_force = i2.totalOfNeighborStrengths(individual);
	competition_ratio = adult_density_force / EXPECTED_ADULT_COMPETITION;
	actual_competition_factor = GROWTH_AT_ZERO_DENSITY/ ((GROWTH_AT_ZERO_DENSITY-1) * competition_ratio + 1);
	
	// Offspring number based on binomial distrobution.
	// p for binomial draw. Number of offspring varies with female genes and competition.
	p = genotypeFitness(individual) * actual_competition_factor * 0.04 / (1 + RATE_FEMALES_SURVIVE);
	num_offspring = rbinom(1, 50, p);
	
	// In the TADS modification drive, males with two r2 are sterile.
	// In TADS autosomal suppression drive, males with two d are also sterile.
	if (TADS_MODIFICATION | TADS_AUTOSOMAL_SUPPRESSION) {
		if (sum(selected_mate.genomes.countOfMutationsOfType(m4) > 0) == 2)
			num_offspring = 0;
		if (TADS_AUTOSOMAL_SUPPRESSION)
			if (sum(selected_mate.genomes.countOfMutationsOfType(m2) == NUM_GRNAS) == 2)
				num_offspring = 0;
	}
	
	for (i in seqLen(num_offspring)) {
		// Add offspring to the subpopulation.
		offspring = subpop.addCrossed(individual, selected_mate);
		if (!isNULL(offspring))
		{
			if (REPRISING_BOUNDARIES)
			{
				// Offspring placement within reprising boundaries.
				if (!ONE_DIMENSIONAL)
				{
					do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				} else
				{
					// Toroidal world offspring placement.
					do position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				}
			}
			else {
				if (!ONE_DIMENSIONAL) {
					position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				} else {
					position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				}
			}
		}
	}
}


//// GENE DRIVE IMPLEMENTATION RULES THAT OCCUR IN EVERY CHILD.
1: modifyChild() {
	
	// If the drive is x-linked, prevent it from being inherited on Y chromosome:
	if (X_LINKED_DRIVE)
		copy_genome(ifelse((child.sex == "F"),parent2.genome1,parent2.genome2), child.genome2);
	
	if (TADS_MODIFICATION | TADS_AUTOSOMAL_SUPPRESSION) {
		// Apply germline resistance
		if (!MALE_ONLY_PROMOTER)
			germline(childGenome1, parent1, GERMLINE_RESISTANCE_RATE);
		germline(childGenome2, parent2, GERMLINE_RESISTANCE_RATE);
		
		// Ensure that the child did not receive a nonviable sperm
		if (parent2.countOfMutationsOfType(m4)==0 & parent2.countOfMutationsOfType(m2) == NUM_GRNAS) {
			while (childGenome2.countOfMutationsOfType(m4) > 0) {
				// Half the time, loop back and give the child drive instead
				if (runif(1) < 0.5)
					childGenome2.addNewDrawnMutation(m2, seqLen(NUM_GRNAS));
				else {
					// Otherwise, recreate the non-drive chromosome before germline resistance
					// and undergo germline resistance again - only exit loop if r2 doesn't result
					copy_genome(ifelse((parent2Genome1.countOfMutationsOfType(m2) == NUM_GRNAS), parent2Genome2, parent2Genome1), childGenome2);
					germline(childGenome2, parent2, GERMLINE_RESISTANCE_RATE);
				}
			}
		}
		
		// Fathers who were r2 heterozygotes cannot pass on an r2 allele. The child must have received the other allele.
		if (childGenome2.countOfMutationsOfType(m4) > 0)
			copy_genome(ifelse((parent2Genome1.countOfMutationsOfType(m4) > 0), parent2Genome2, parent2Genome1), childGenome2);
		
		if (!MALE_ONLY_PROMOTER)
			embryo(childGenome1, childGenome2, parent1);
	}
	
	if (!(TADS_MODIFICATION|TADS_AUTOSOMAL_SUPPRESSION)) {
		// Apply effects that happen in the germline.
		if (!MALE_ONLY_PROMOTER)
			germline(child.genome1, parent1, GERMLINE_RESISTANCE_RATE);
		germline(child.genome2, parent2, GERMLINE_RESISTANCE_RATE);
		
		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
			embryo(child.genome1, child.genome2, parent1);
	}
	
	// If the drive is x-linked, prevent gene drive mechanics on Y chromosome by resetting it:
	if (X_LINKED_DRIVE) {
		if(child.sex == "M")
			copy_genome(parent2.genome2, child.genome2);
	
	}
	
	// Offspring may be non viable offspring if drive
	// is haplolethal or haplosufficient recessive lethal.
	num_drives = sum(child.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	num_r2s = sum(child.genomes.countOfMutationsOfType(m4) > 0);
	
	haplolethal_one_rescue = ifelse((TADE|TADE_SUPPRESSION),T,F);
	
	haplosufficiency = ifelse((TARE), T, F);
	
	// If drive is haplolethal, the offspring is nonviable if it received any drive
	if (haplolethal_one_rescue & (num_r2s > 0))
		return F;
	
	// For TADE double rescue, the offspring is only nonviable if it obtained an r2 without any drives
	if (TADE_DOUBLE_RESCUE & (num_r2s > 0) & (num_drives==0))
		return F;
	
	// If drive is haplosufficient, offspring is nonviable if it received two r2
	if (haplosufficiency & num_r2s==2)
		return F;
	
	//If drive is X-linked and the offspring is male with at least one r2, it is nonviable.
	if (haplosufficiency & X_LINKED_DRIVE & (child.sex == "M") & (num_r2s > 0))
		return F;
	
	return T;
}

//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
	all = sim.subpopulations.individuals;
	all.color = "blue"; // wt individuals are blue
	two_res = (all.genome1.countOfMutationsOfType(m4) | all.genome1.countOfMutationsOfType(m3) == NUM_GRNAS) & (all.genome2.countOfMutationsOfType(m4) | all.genome2.countOfMutationsOfType(m3) == NUM_GRNAS);
	all[two_res].color = "orange"; // Resistance homozygotes are yellow
	all[all.countOfMutationsOfType(m2) >= NUM_GRNAS].color = "red"; // Drive-carrying individuals are red
}

late() {
	i1.evaluate(sim.subpopulations);
	i2.evaluate(sim.subpopulations);
}

//// SURVIVAL RULES FOR THE SIMULATION BASED ON AGE
late() {
	all = sim.subpopulations.individuals;
	
	//Males don't live past one generation
	all[all.sex=="M"].fitnessScaling = 0.0;
	
	//Females may survive to the next generation at the rate specified by user.
	
	females = all[all.sex=="F"];
	females[females.age > 0].fitnessScaling = 0.0;
	females[females.age==0].fitnessScaling = RATE_FEMALES_SURVIVE;
	
	surviving_inds = all[all.fitnessScaling > 0.0];
	
	// Surviving individuals move
	for (ind in surviving_inds) {
		if (REPRISING_BOUNDARIES) {
			do position = ind.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
			while (!ind.subpopulation.pointInBounds(position));
			ind.setSpatialPosition(position);
		} else {
			// Toroidal world movement.
			ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
			ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
		}
	}
}


//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 early() {
	// Start with a population of wild type flies.
	sim.addSubpop("p1", CAPACITY);
	all= p1.individuals;
	all.genomes.addNewDrawnMutation(m1,seqLen(NUM_GRNAS));
	all.x=p1.pointUniform(CAPACITY);
	sim.setValue("timer", "start");

}


//// DROP A GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
10 early() {
	// Add a drop of modified individuals to p1.
	if (MALE_ONLY_DROP)
		// Drop a population of only males.
		sim.addSubpop("p2", DROP_SIZE, 1.0);
	else if (FEMALE_ONLY_DROP)
		// Drop a population of only females.
		sim.addSubpop("p2", DROP_SIZE, 0.0);
	else
		sim.addSubpop("p2", DROP_SIZE);
	
	drop = p2.individuals;
	
	// Now set the drop individuals to the correct genotypes:
	drop.genomes.addNewDrawnMutation(m2,seqLen(NUM_GRNAS));
	
	// For heterozygous drop, one of the chromosomes is set to wild type:
	if (HETEROZYGOUS_DROP)
		drop.genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
	
	// In X_LINKED_DRIVE males' genome2 (from father) is always wt.
	if (X_LINKED_DRIVE)
		drop[drop.sex == "M"].genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
	
	// Move all the individuals from the drop into p1:
	p1.takeMigrants(drop);
	drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
	p2.removeSubpopulation();
}


//// PROGRAM OUTPUT.
10:late() {
	catn("MARKER");
	all = sim.subpopulations.individuals;
	this_gen = sim.cycle-10;
	target=all[all.countOfMutationsOfType(m2) != 0];
	tx=target.x;	
	slice_x3= (tx >0.2) & (tx <= 0.3);
	slice3=target[slice_x3];
	num_x3_1 = all[(all.x > 0.2) & (all.x < 0.3)];
	females_3 = num_x3_1[num_x3_1.sex == "F"];
	males_3 = num_x3_1[num_x3_1.sex == "M"];
	num_x_chromo_3 = 2*size(females_3) + size(males_3);
	num_dr_3 = sum(slice3.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
   rate_dr_3 = num_dr_3/num_x_chromo_3;
   
   
	timer = sim.getValue("timer");
	

	
	//only start timer once
	if (rate_dr_3 >= BAR) {
		if (timer == "start") {
			thisgen=sim.cycle-10;
			catn("STARTING_TIMER_AT:" + thisgen);
			catn("STARTING_FREQUENCY:"+rate_dr_3);
			sim.setValue("timer", thisgen);
		}
	}
	
	slice_x8= (tx >0.7) & (tx <= 0.8);
	slice8=target[slice_x8];
	num_x8_1 = all[(all.x > 0.7) & (all.x < 0.8)];
	females_8 = num_x8_1[num_x8_1.sex == "F"];
	males_8 = num_x8_1[num_x8_1.sex == "M"];
	num_x_chromo_8 = 2*size(females_8) + size(males_8);
	num_dr_8 = sum(slice8.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
   rate_dr_8 = num_dr_8/num_x_chromo_8;
	
	if (rate_dr_8 >= BAR) {
		start_gen = sim.getValue("timer");
		this_gen = sim.cycle-10;
		gens_elapsed = this_gen - start_gen;
		catn("STOPPING_TIMER_AT:" + this_gen);
		catn("STOPPING_FREQUENCY:"+rate_dr_8);
	}		
	
	
	n=0;
	if(rate_dr_3 >= 0.5 & rate_dr_8 <= 0.5){
		catn("generation:"+this_gen);
		do{
			if(any((all.x > (n/50)) & (all.x <= ((n+1)/50))))
			{
				all_slice_helper =(all.x > (n/50)) & (all.x < ((n+1)/50));
				all_slice = all[all_slice_helper];
				males = all_slice[all_slice.sex=="M"];
				females = all_slice[all_slice.sex=="F"];
				
				Drive_homo_females = females[females.countOfMutationsOfType(m2)
					== 2*NUM_GRNAS];
				One_drive_females = females[females.countOfMutationsOfType(m2)==NUM_GRNAS];
				One_drive_males = males[males.countOfMutationsOfType(m2)==NUM_GRNAS];
				Wild_R2_females = females[females.countOfMutationsOfType(m1)==NUM_GRNAS & females.countOfMutationsOfType(m4)==NUM_GRNAS];
				Wild_males = males[males.countOfMutationsOfType(m1)
					== 2*NUM_GRNAS];
				Wild_females = females[females.countOfMutationsOfType(m1)
					== 2*NUM_GRNAS];
				number = size(Drive_homo_females)+size(One_drive_females)+size(One_drive_males)+size(Wild_R2_females)+size(Wild_males)+size(Wild_females)-size(all_slice);
				drive_carrier_freq = (length(Drive_homo_females)+length(One_drive_females)+length(One_drive_males))/length(all_slice);
				LEFT=n/50;
				RIGHT=(n+1)/50;
				CORE = (LEFT + RIGHT)/2;
				catn("POSITION:"+CORE+":DRIVE_CARRIER_FREQUENCY:"+drive_carrier_freq);
				n=n+1;
				if(n==50)
					catn("#######");
			
			
			}
			else{
				LEFT=n/50;
				RIGHT=(n+1)/50;
				CORE = (LEFT + RIGHT)/2;
				catn("POSITION:"+CORE+":DRIVE_CARRIER_FREQUENCY:NULL");
				n=n+1;
				if(n==50)
					catn("#######");
			}
		}while(n<50);
	
	}
	if(rate_dr_8 > 0.5)
		sim.simulationFinished();
}


//// PROGRAM END CONDITION.
210 late() {
	sim.simulationFinished();
}

