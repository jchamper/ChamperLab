                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
// Author: Sam Champer and Isabel Kim.
// Created in association with Jackson Champer and the Messer lab.

// A framework for simulating many different gene drives
// with varying parameters, intended to be configured by
// alterning the heading below, or by dynamically varying
// values in the header using an associated Python file.

// The following header to be replaced via python,
// such that these values can be varied across multiple runs of slim.

//these constants may change based on cluster runs

//TARE drive & Homing suppression drive with embryo cut
//Troubleshooting 
// Evenly drop, about 10%-20% amount of the total numbers
// increase the migration rate to 0.1
// increase the density interaction radius to 0.04 
// record the frequency of total drive alleles and the frequency of the drive carriers in 50 generations
//DROP1:DD++
//DROP2:++H+

initialize() {
	//test parameters
	defineConstant("CAPACITY", 50000);
	defineConstant("HOMING_DRIVE_TEST", F);
	defineConstant("TWO_RELEASES", F);
	defineConstant("DROP_PERCENTAGE_OVERRIDE_TARE", 0.90);
	defineConstant("DROP_PERCENTAGE_OVERRIDE_HOM", 0.50);
	defineConstant("DROP_ADDS_TO_POP", F);  // If T, the drop is added to the population, rather than overwriting preexisting individuals.
	defineConstant("TARE_DRIVE_PREDICTION",16.43786848);//TARE drive prediction is 16.43786848 generations to travel 0.5
	
	
	//gRNA parameters
	defineConstant("NUM_GRNAS", 1);
	defineConstant("GRNA_SATURATION_SIMULATED",F);
	
	// Cut parameters:
	// TARE drive germline cut parameters
	defineCfgParam("GERMLINE_RESISTANCE_RATE_TARE", 1.00);
	
	
	// TARE drive embryo cut parameters
	defineCfgParam("EMBRYO_RESISTANCE_RATE_TARE", 1.00);//TARE EMBRYO CUT;then more, the more efficient TARE drive is 
	
	// HOMING suppression drive performance parameters
	defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_HOM",0.00);//before hdr no cut then drive conversion rate will be HOMING_PHASE_CUT_RATE
	//defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_F_HOM",0.00);//0.01
	//defineCfgParam("GERMLINE_RESISTANCE_CUT_RATE_M_HOM",0.00);//0.02
	defineCfgParam("HOMING_PHASE_CUT_RATE",1.00 );//0.99 0.8-1.0 drive conversion rate when germline_resistance_cut_rate_F/M_HOM=0, otherwise drive conversion rate will be (1-germline_resistance_cut_rate_F/M_HOM)*HOMING_PHASE_CUT_RATE; because it will become resistance allele before hdr
	//defineCfgParam("HOMING_PHASE_CUT_RATE_F",1.00);//0.99
	//defineCfgParam("HOMING_PHASE_CUT_RATE_M",1.00);//0.96
	defineConstant("LATE_GERMLINE_RESISTANCE_RATE", 1.00);//after hdr all the drive that does not do drive conversion will become resistance allele
	defineCfgParam("EMBRYO_RESISTANCE_CUT_RATE_HOM",0.00);//0.00-1.00 HOMING EMBRYO CUT, the more, the slower HOMS is 
	defineConstant("BASELINE_HOMING_SUCCESS_RATE",1.0);
	defineConstant("HOMING_EDGE_EFFECT",0.1);
	defineConstant("R1_OCCURRENCE_RATE", 0.0);
	defineConstant("NUM_CUT_PHASES", 1);
	
	// TARE Fitness parameters:
	defineCfgParam("TARE_DD_FITNESS_VALUE", 1.00);
	defineCfgParam("TARE_DX_FITNESS_VALUE", sqrt(TARE_DD_FITNESS_VALUE));
	defineCfgParam("TARE_SOMATIC_FITNESS_MUTLIPLIER", 1.00);
	defineCfgParam("TARE_SOMATIC_FITNESS_MUTLIPLIER_F", TARE_SOMATIC_FITNESS_MUTLIPLIER);
	defineCfgParam("TARE_SOMATIC_FITNESS_MUTLIPLIER_M", 1.00);
	// HOMS Fitness parameters:
	defineCfgParam("DD_FITNESS_VALUE", 1.00);
	defineCfgParam("DX_FITNESS_VALUE", sqrt(DD_FITNESS_VALUE));
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER", 1.00);
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER_F", SOMATIC_FITNESS_MUTLIPLIER);
	defineCfgParam("SOMATIC_FITNESS_MUTLIPLIER_M", 1.00);

	
	// Release specifics:
	defineConstant("NO_DROP", F);
	defineConstant("CIRCLE_DROP", T);
	defineConstant("LEFT_EDGE_DROP", F);
	defineConstant("UNIFORM_DROP", F);
	defineConstant("CORNER_DROP",F);
	defineConstant("WT_START",F);
	
	//Dimensional sets.
	defineConstant("ONE_DIMENSIONAL",F);
	defineConstant("TWO_DIMENSIONAL",T);
	defineConstant("REPRISING_BOUNDARIES", T); // If F, toroidal boundaries are used: move out of the right boundary and appear in the left boundary. 
	defineConstant("DENSITY_INTERACTION_DISTANCE", 0.01);
	defineConstant("DROP_RADIUS", 0.1);
	defineConstant("EQUILIBRIUM_WT_ALLELE_THRESHOLD", 0.8*2*CAPACITY);
	
	defineCfgParam("AVERAGE_DISTANCE", 0.05);
	if (TWO_DIMENSIONAL){
		defineConstant("SPEED", AVERAGE_DISTANCE*sqrt(2/PI));
		defineConstant("NUMBER_OF_CELLS", 64);
		defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY * PI * DENSITY_INTERACTION_DISTANCE^2);
		
	}
	if (ONE_DIMENSIONAL){
		defineConstant("SPEED", AVERAGE_DISTANCE*sqrt(PI/2));
		defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY*DENSITY_INTERACTION_DISTANCE);
		defineConstant("NUMBER_OF_CELLS", 40);
		defineConstant("EQUILIBRIUM_BIN_POPULATION", 0.5*CAPACITY/20);

	}
	defineConstant("FEMALE_SPEED", SPEED);
	defineConstant("MATING_DISTANCE", AVERAGE_DISTANCE);
	defineCfgParam("GROWTH_AT_ZERO_DENSITY",6.00);
	defineConstant("INBREEDING_AVOIDANCE_FACTOR", 0.0); // If negative, this is a % increase. If positive, this is a % decrease
	defineConstant("INBREEDING_FECUNDITY_PENALTY", 0.0); // Ranges from 0 - 1. Always a % decrease
	
	
	
	// drive parameters
	defineConstant("TADE",F);
	defineConstant("TADE_SUPPRESSION", F);
	defineConstant("TADE_DOUBLE_RESCUE",F);
	defineConstant("TARE", T);
	defineConstant("TADS_AUTOSOMAL_SUPPRESSION", F);
	defineConstant("TADS_MODIFICATION", F);
	defineConstant("RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE", T);
	defineConstant("RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE", F);
	defineConstant("RECESSIVE_BOTH_SEX_LETHAL_SUPPRESSION_DRIVE", F);
	defineConstant("HAPLOLETHAL",F);
	defineConstant("HAPLOSUFFICIENT",T);
	defineConstant("X_LINKED_DRIVE", F);
	
	
	// chase detection
	defineConstant("TRACK_BY_CELL", T); //for chase detection in suppression drives
	//defineConstant("SUPPRESSION_OUTPUT", RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE |
	//RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE |
	//RECESSIVE_BOTH_SEX_LETHAL_SUPPRESSION_DRIVE | TADE_SUPPRESSION |
	//TADS_AUTOSOMAL_SUPPRESSION);
	// */    // End header.
	
	// For mortality rate as a function of age:
	// Some females are allowed to survive two generations:
	defineConstant("RATE_FEMALES_SURVIVE", 0.0);
	
	// This simulation will use a non-Wright-Fisher model.
	initializeSLiMModelType("nonWF");
	
	// This simulation will take place across continuous space.
	if (ONE_DIMENSIONAL) {
		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "x"); //for 1-D
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="x", periodicity="x");
		initializeInteractionType(1, "x", reciprocal=T, maxDistance=MATING_DISTANCE);
		initializeInteractionType(2, "x", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	}
			
	if (TWO_DIMENSIONAL) {
		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "xy");
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="xy", periodicity="xy");
		
		// Mate searching:
		initializeInteractionType(1, "xy", reciprocal=T, maxDistance=MATING_DISTANCE);
		// Adult competition:
		initializeInteractionType(2, "xy", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	}
	
	// Four variations: Wild type, drive, r1 resistance, r2 resistance.
	wt = initializeMutationType("m1", 0.5, "f", 0.0);
	dr = initializeMutationType("m2", 0.5, "f", 0.0);
	r1 = initializeMutationType("m3", 0.5, "f", 0.0);
	r2 = initializeMutationType("m4", 0.5, "f", 0.0);
	cut = initializeMutationType("m5", 0.5, "f", 0.0);
	gap = initializeMutationType("m6", 0.5, "f", 0.0);
	hwt = initializeMutationType("m7", 0.5, "f", 0.0);
	hdr = initializeMutationType("m8", 0.5, "f", 0.0);
	hr1 = initializeMutationType("m9", 0.5, "f", 0.0);
	hr2 = initializeMutationType("m10", 0.5, "f", 0.0);
	hcut = initializeMutationType("m11", 0.5, "f", 0.0);
	hgap = initializeMutationType("m12", 0.5, "f", 0.0);
	variations_TARE = c(wt, dr, r1, r2, cut, gap);
	variations_HOM= c(hwt, hdr, hr1, hr2, hcut, hgap);
	
	
	// Variations are all part of g1 genome element.
	initializeGenomicElementType("g1", variations_TARE, c(1, 1, 1, 1, 1, 1));
	initializeGenomicElementType("g2", variations_HOM, c(1, 1, 1, 1, 1, 1));
	
	// Element is NUM_GRNAS long, each spot on the element representing a GRNA target location.
	initializeGenomicElement(g1, 0, NUM_GRNAS - 1);
	initializeGenomicElement(g2, NUM_GRNAS, NUM_GRNAS);
	
	// These mutations overwrite one another.
	variations_TARE.mutationStackPolicy = "l";
	variations_TARE.mutationStackGroup = 1;
	variations_HOM.mutationStackPolicy = "l";
	variations_HOM.mutationStackGroup = 1;
	
	// No mutation in this model.
	initializeRecombinationRate(0.5);
	initializeMutationRate(0.0);
	
	// Simulate sexual reproduction: A for autosome.
	initializeSex("A");
}

function (void) defineCfgParam(string$ name, lifs value) {
	if (!exists(name))
		defineConstant(name, value);
}


//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH HAPLOLETHAL STYLE SUPPRESSION.
function (logical)isHLSuppressed(o<Individual>$ ind) {
	// Check both chromosomes for the drive.	
	// Individual cannot reproduce if both chromosomes have a drive.
	if (sum(ind.genomes.countOfMutationsOfType(m2)==NUM_GRNAS)==2)
		return T;
	return F;
}

//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH RECESSIVE FEMALE or MALE STERILITY STYLE SUPPRESSION.
function (logical)isRecessiveSterilitySuppressed(o<Individual>$ ind) {
	// Check both chromosomes for drive and type 2 resistance allele. These are the only variants that affect suppression.
	
	// Individual cannot reproduce if both chromosomes have either a drive or an r2.
	if ((ind.genome1.countOfMutationsOfType(m8) == NUM_GRNAS | ind.genome1.countOfMutationsOfType(m10) > 0) & (ind.genome2.countOfMutationsOfType(m8) == NUM_GRNAS| ind.genome2.countOfMutationsOfType(m10) > 0))
		return T;
	return F;
}


//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addTAREResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m3 is r1, m4 is r2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}
//// FORMING A RESISTANCE ALLELE AT A HOMING SUPPRESSION DRIVE SITE
function (void)addHOMResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m9 is hr1, m10 is hr2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m9, m10), locus);
}



//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate_TARE, f$ resistance_rate_HOM) {
	if (HOMING_DRIVE_TEST){
		// Determine presence of drive in this parent.
		parent_drive_count = sum(parent.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
		// If parent doesn't have drive allele, nothing happens in germline.
		if (!parent_drive_count)
			return;
		
		// Chromosome must have wt to cut, or nothing happens.
		if (child_chromosome.countOfMutationsOfType(m7)==0)
			return;
		
		// Using the resistance rate passed to the function,
		// determine the per phase cut rate.
		grna_factor = 1;
		if (GRNA_SATURATION_SIMULATED)
			grna_factor = NUM_GRNAS;
		per_phase_cut_rate_HOM = 1 - (1 - resistance_rate_HOM)^(1 / (NUM_CUT_PHASES * grna_factor));
		
		// Determine if cas9 cuts the chromosome in the germline.
		casCut_HOM(child_chromosome, per_phase_cut_rate_HOM);
	
	}else{
		parent_drive_count_TARE = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
		if (!parent_drive_count_TARE)
			return;
		if (child_chromosome.countOfMutationsOfType(m1) == 0){
			parent_drive_count_HOM = sum(parent.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
			if (!parent_drive_count_HOM)
				return;
			if (child_chromosome.countOfMutationsOfType(m7) == 0)
				return;
			grna_factor = 1;
			per_phase_cut_rate_HOM = 1 - (1 - resistance_rate_HOM)^(1 / (NUM_CUT_PHASES * grna_factor));
			// Determine if cas9 cuts the chromosome in the germline.
			casCut_HOM(child_chromosome, per_phase_cut_rate_HOM);
		
		}else{
			grna_factor = 1;
			per_phase_cut_rate_TARE = 1 - (1 - resistance_rate_TARE)^(1 / (NUM_CUT_PHASES * grna_factor));
			// Determine if cas9 cuts the chromosome in the germline.
			casCut_TARE(child_chromosome, per_phase_cut_rate_TARE);
			parent_drive_count_HOM = sum(parent.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
			if (!parent_drive_count_HOM)
				return;
			if (child_chromosome.countOfMutationsOfType(m7) == 0)
				return;
			grna_factor = 1;
			per_phase_cut_rate_HOM = 1 - (1 - resistance_rate_HOM)^(1 / (NUM_CUT_PHASES * grna_factor));
			// Determine if cas9 cuts the chromosome in the germline.
			casCut_HOM(child_chromosome, per_phase_cut_rate_HOM);
		}
	}
}

//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE AFTER HDR IN HOMING SUPPRESSION.
function (void)late_germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
	parent_drive_count_TARE = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	if (!parent_drive_count_TARE)
		return;
	// Determine presence of drive in this parent.
	parent_drive_count_HOMS = sum(parent.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
	// If parent doesn't have drive allele, nothing happens in germline.
	if (!parent_drive_count_HOMS)
		return;
		
	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m7)==0)
		return;
	
	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(1 / (NUM_CUT_PHASES * grna_factor));
	
	// Determine if cas9 cuts the chromosome in the germline.
	casCut_HOM(child_chromosome, per_phase_cut_rate);
}


//// FUNCTION FOR TARE CAS9 EFFECTS IN EMBRYO.
function (void)embryo_TARE(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother) {
	// Determine presence of drive in this mother.
	mother_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If mother doesn't have drive allele, nothing happens in embryo.
	if (!mother_drive_count)
		return;
	
	// Determine the per phase cut rate.
	grna_factor = 1;
	per_phase_cut_rate = 1 - (1 - EMBRYO_RESISTANCE_RATE_TARE)^(mother_drive_count / (NUM_CUT_PHASES * grna_factor));
	
	// Then pass this rate as an argument to  the casCut funtion to
	// determine if cas9 cuts in the embryo for each chromosome.
	casCut_TARE(child_chromosome_1, per_phase_cut_rate);
	casCut_TARE(child_chromosome_2, per_phase_cut_rate);
}

//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo_HOM(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother, f$ resistance_rate) {
	if (HOMING_DRIVE_TEST){
		mother_HOM_drive_count = sum(mother.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
		if (!mother_HOM_drive_count)
			return;
		
		cas_factor = mother_HOM_drive_count;
		// cas_factor means the amount of cas9; dr/dr means two cas9, dr/wt means 1.82 instead of 1.
		// Determine the per phase cut rate.
		if (sum(mother.genomes.countOfMutationsOfType(m7) == NUM_GRNAS) == 1)
			// Special case for homing drive individual that is dr/wt based on experimental data.
			cas_factor = 1.82;
		grna_factor = 1;
		if (GRNA_SATURATION_SIMULATED)
			grna_factor = NUM_GRNAS;
		per_phase_cut_rate = 1 - (1 - resistance_rate)^(cas_factor / (NUM_CUT_PHASES * grna_factor));
		
		// Then pass this rate as an argument to  the casCut funtion to
		// determine if cas9 cuts in the embryo for each chromosome.
		casCut_HOM(child_chromosome_1, per_phase_cut_rate);
		casCut_HOM(child_chromosome_2, per_phase_cut_rate);
	
	}else{
		// Determine presence of drive in this mother.
		mother_TARE_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
		// If mother doesn't have drive allele, nothing happens in embryo.
		if (!mother_TARE_drive_count)
			return;
		mother_HOM_drive_count = sum(mother.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
		if (!mother_HOM_drive_count)
			return;
			
		// cas_factor means the amount of cas9; dr/dr means two cas9, dr/wt means 1.82 instead of 1. only in homing drives
		cas_factor = mother_TARE_drive_count;
		// Determine the per phase cut rate.
		if (sum(mother.genomes.countOfMutationsOfType(m1) == NUM_GRNAS) == 1)
			// Special case for homing drive individual that is dr/wt based on experimental data.
			cas_factor = 1.82;
		grna_factor = 1;
		if (GRNA_SATURATION_SIMULATED)
			grna_factor = NUM_GRNAS;
		per_phase_cut_rate = 1 - (1 - resistance_rate)^(cas_factor/ (NUM_CUT_PHASES * grna_factor));
		
		// Then pass this rate as an argument to  the casCut funtion to
		// determine if cas9 cuts in the embryo for each chromosome.
		casCut_HOM(child_chromosome_1, per_phase_cut_rate);
		casCut_HOM(child_chromosome_2, per_phase_cut_rate);
	}
}


//// FUNCTION FOR TARE CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut_TARE(o<Genome>$ chromosome, f$ per_phase_cut_rate) {
	if (chromosome.countOfMutationsOfType(m1) ==0)
		return;
	wt_loci_TARE = chromosome.positionsOfMutationsOfType(m1);
	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci_TARE)) {
			// Check to see if cas9 cuts...
			if (runif(1) < per_phase_cut_rate) {
				// Convert the locus temporarily to an m5,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m5, wt_loci_TARE[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m5)) {
			cut_loci_TARE = chromosome.positionsOfMutationsOfType(m5);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m5) == 1)
				addTAREResistanceAllele(chromosome, cut_loci_TARE[0]);
			else {
				// If multiple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m4 (R2)
				// everything else through the rightmost site to m6 (cut).
				number_of_cuts_TARE = cut_loci_TARE[size(cut_loci_TARE) - 1] - cut_loci_TARE[0];
				for (index in seqLen(number_of_cuts_TARE))
					chromosome.addNewDrawnMutation(m6, cut_loci_TARE[0] + index + 1);
				chromosome.addNewDrawnMutation(m4, cut_loci_TARE[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites.
			if (chromosome.countOfMutationsOfType(m1) == 0)
				return;
			wt_loci_TARE = chromosome.positionsOfMutationsOfType(m1);
		}
	}
}
//// FUNCTION FOR HOM CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut_HOM(o<Genome>$ chromosome, f$ per_phase_cut_rate) {
	if (chromosome.countOfMutationsOfType(m7) ==0)
		return;
	wt_loci_HOM = chromosome.positionsOfMutationsOfType(m7);
	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci_HOM-1)) {
			// Check to see if cas9 cuts...
			if (runif(1) < per_phase_cut_rate) {
				// Convert the locus temporarily to an m11,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m11, wt_loci_HOM[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(11)) {
			cut_loci_HOM = chromosome.positionsOfMutationsOfType(m11);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m11) == 1)
				addHOMResistanceAllele(chromosome, cut_loci_HOM[0]);
			else {
				// If multiple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m10 (R2)
				// everything else through the rightmost site to m12 (cut).
				number_of_cuts_HOM = cut_loci_HOM[size(cut_loci_HOM) - 1] - cut_loci_HOM[0];
				for (index in seqLen(number_of_cuts_HOM))
					chromosome.addNewDrawnMutation(m12, cut_loci_HOM[0] + index + 1);
				chromosome.addNewDrawnMutation(m10, cut_loci_HOM[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites.
			if (chromosome.countOfMutationsOfType(m7) == 0)
				return;
			wt_loci_HOM = chromosome.positionsOfMutationsOfType(m7);
		}
	}
}



//// FUNCTION FOR SIMULATING HOMING THAT OCCURS DURING HOMOLOGY DIRECTED REPAIR.
function (void)hdr(o<Genome>$ chromosome, o<Individual>$ parent, f$ cut_rate) {
	// Determine presence of Cas9
	if (HOMING_DRIVE_TEST){
		if (parent.countOfMutationsOfType(m8)==0)
			return;
		// If chromosome has no wild type targets to cut, cas9 does nothing.
		if (chromosome.countOfMutationsOfType(m7)==0)
			return;
		// Rate of cutting occurs at the HOMING_PHASE_CUT_RATE, modified by gRNA saturation, if toggled on.
		cut_rate = HOMING_PHASE_CUT_RATE;
		if (GRNA_SATURATION_SIMULATED)
			cut_rate = 1 - (1 - HOMING_PHASE_CUT_RATE)^(1/NUM_GRNAS);
		
		// Vector of possible loci.
		wt_loci_HOM = chromosome.positionsOfMutationsOfType(m7);
		
		// At each possible locus...
		for (i in seqAlong(wt_loci_HOM))
			// Check to see if cas9 cuts...
			if (runif(1) < cut_rate)
				// Convert the locus temporarily to an m11,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m11, wt_loci_HOM[i]);
		
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m11)) {
			// Determine how extreme the cuts are relative to the target package (the drive).
			cut_loci_HOM = chromosome.positionsOfMutationsOfType(m11);
			leftmost_cut_index = cut_loci_HOM[0];
			rightmost_cut_index = cut_loci_HOM[size(cut_loci_HOM) - 1];
			// Sections that have already been cut out of the chromosome
			// also contribute to the size of the cut section.
			missing_loci_HOM = chromosome.positionsOfMutationsOfType(m12);
			// Adjusted indecies are amounts by which the cut ends differ
			// from the perfect cut that spans the entire target area.
			adjusted_left_index = leftmost_cut_index - sum(missing_loci_HOM <
				leftmost_cut_index);
			rightmost_cut_index = rightmost_cut_index + sum(missing_loci_HOM >
				rightmost_cut_index);
			adjusted_right_index = NUM_GRNAS - 1 - rightmost_cut_index;
			successful_homing_rate = BASELINE_HOMING_SUCCESS_RATE * (1 -
				HOMING_EDGE_EFFECT * adjusted_left_index) * (1 - HOMING_EDGE_EFFECT *
				adjusted_right_index);
			
			// Check to see if homing succeeds.
			if (runif(1) < successful_homing_rate)
				for (i in seqLen(NUM_GRNAS))
					chromosome.addNewDrawnMutation(m8, i+1);
			else {
				// A small percentage of individuals have complete failures of the homing drive,
				// resulting in the entire section of the chromosome becoming a resistance allele.
				total_failure_avoidance_rate = 0.9 * (1 - 0.1 * adjusted_left_index) * (1 - 0.1 * adjusted_right_index);
				if (runif(1) < total_failure_avoidance_rate) {
					// Some catastrophic failures become all R1, at the following rate:
					total_r1_rate = 0.001 * (1 + adjusted_right_index -
						adjusted_left_index);
					// All-R1 catastrophic failures occur only in HAPLOSUFFICIENT or HAPLOSLETHAL drives.
					if (runif(1) < total_r1_rate & (HAPLOLETHAL |
						HAPLOSUFFICIENT))
						for (i in seqLen(NUM_GRNAS))
							chromosome.addNewDrawnMutation(m9, i+1);
					else
						for (i in seqLen(NUM_GRNAS))
							chromosome.addNewDrawnMutation(m10, i+1);
				}
				// If neither homing nor a catastrophic failure occur, normal repair happens.
				else {
					// If just one cut was made, create an R1 or R2 resistance allele.
					if (chromosome.countOfMutationsOfType(m11) == 1)
						addHOMResistanceAllele(chromosome, cut_loci_HOM[0]);
					else {
						// If mutlple cuts were made, leftmost site to m10 (R2),
						// everthing else through the rightmost site to m12 (cut).
						number_of_cuts_HOM = cut_loci_HOM[size(cut_loci_HOM) - 1] - cut_loci_HOM[0];
						for (index in seqLen(number_of_cuts_HOM))
							chromosome.addNewDrawnMutation(m12, cut_loci[0] + index + 1);
						chromosome.addNewDrawnMutation(m10, cut_loci[0]);
					}
				}
			}
		}
	
	}else{
		if (parent.countOfMutationsOfType(m2)==0)
			return;
		if (parent.countOfMutationsOfType(m8)==0)
			return;
		// If chromosome has no wild type targets to cut, cas9 does nothing.
		if (chromosome.countOfMutationsOfType(m7)==0)
			return;
		// Rate of cutting occurs at the HOMING_PHASE_CUT_RATE, modified by gRNA saturation, if toggled on.
		cut_rate = HOMING_PHASE_CUT_RATE;
		if (GRNA_SATURATION_SIMULATED)
			cut_rate = 1 - (1 - HOMING_PHASE_CUT_RATE)^(1/NUM_GRNAS);
		
		// Vector of possible loci.
		wt_loci_HOM = chromosome.positionsOfMutationsOfType(m7);
		
		// At each possible locus...
		for (i in seqAlong(wt_loci_HOM))
			// Check to see if cas9 cuts...
			if (runif(1) < cut_rate)
				// Convert the locus temporarily to an m11,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m11, wt_loci_HOM[i]);
		
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m11)) {
			// Determine how extreme the cuts are relative to the target package (the drive).
			cut_loci_HOM = chromosome.positionsOfMutationsOfType(m11);
			leftmost_cut_index = cut_loci_HOM[0];
			rightmost_cut_index = cut_loci_HOM[size(cut_loci_HOM) - 1];
			// Sections that have already been cut out of the chromosome
			// also contribute to the size of the cut section.
			missing_loci_HOM = chromosome.positionsOfMutationsOfType(m12);
			// Adjusted indecies are amounts by which the cut ends differ
			// from the perfect cut that spans the entire target area.
			adjusted_left_index = leftmost_cut_index - sum(missing_loci_HOM <
				leftmost_cut_index);
			rightmost_cut_index = rightmost_cut_index + sum(missing_loci_HOM >
				rightmost_cut_index);
			adjusted_right_index = NUM_GRNAS - 1 - rightmost_cut_index;
			successful_homing_rate = BASELINE_HOMING_SUCCESS_RATE * (1 -
				HOMING_EDGE_EFFECT * adjusted_left_index) * (1 - HOMING_EDGE_EFFECT *
				adjusted_right_index);
			
			// Check to see if homing succeeds.
			if (runif(1) < successful_homing_rate)
				for (i in seqLen(NUM_GRNAS))
					chromosome.addNewDrawnMutation(m8, i+1);
			else {
				// A small percentage of individuals have complete failures of the homing drive,
				// resulting in the entire section of the chromosome becoming a resistance allele.
				total_failure_avoidance_rate = 0.9 * (1 - 0.1 * adjusted_left_index) * (1 - 0.1 * adjusted_right_index);
				if (runif(1) < total_failure_avoidance_rate) {
					// Some catastrophic failures become all R1, at the following rate:
					total_r1_rate = 0.001 * (1 + adjusted_right_index -
						adjusted_left_index);
					// All-R1 catastrophic failures occur only in HAPLOSUFFICIENT or HAPLOSLETHAL drives.
					if (runif(1) < total_r1_rate & (HAPLOLETHAL |
						HAPLOSUFFICIENT))
						for (i in seqLen(NUM_GRNAS))
							chromosome.addNewDrawnMutation(m9, i+1);
					else
						for (i in seqLen(NUM_GRNAS))
							chromosome.addNewDrawnMutation(m10, i+1);
				}
				// If neither homing nor a catastrophic failure occur, normal repair happens.
				else {
					// If just one cut was made, create an R1 or R2 resistance allele.
					if (chromosome.countOfMutationsOfType(m11) == 1)
						addHOMResistanceAllele(chromosome, cut_loci_HOM[0]);
					else {
						// If mutlple cuts were made, leftmost site to m10 (R2),
						// everthing else through the rightmost site to m12 (cut).
						number_of_cuts_HOM = cut_loci_HOM[size(cut_loci_HOM) - 1] - cut_loci_HOM[0];
						for (index in seqLen(number_of_cuts_HOM))
							chromosome.addNewDrawnMutation(m12, cut_loci[0] + index + 1);
						chromosome.addNewDrawnMutation(m10, cut_loci[0]);
					}
				}
			}
		}
	}
}

/*
//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m1))) //m1 loci (wt)
		destination.addNewDrawnMutation(m1, source.positionsOfMutationsOfType(m1)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m2))) //m2 loci (dr)
		destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m3))) //m3 loci (r1)
		destination.addNewDrawnMutation(m3, source.positionsOfMutationsOfType(m3)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m4))) //m4 loci (r2)
		destination.addNewDrawnMutation(m4, source.positionsOfMutationsOfType(m4)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m5))) //m5 loci (cut)
		destination.addNewDrawnMutation(m5, source.positionsOfMutationsOfType(m5)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m6))) //m6 loci (gap)
		destination.addNewDrawnMutation(m6, source.positionsOfMutationsOfType(m6)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m7))) //m7 loci (hwt)
		destination.addNewDrawnMutation(m7, source.positionsOfMutationsOfType(m7)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m8))) //m8 loci (hdr)
		destination.addNewDrawnMutation(m8, source.positionsOfMutationsOfType(m8)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m9))) //m9 loci (hr1)
		destination.addNewDrawnMutation(m9, source.positionsOfMutationsOfType(m9)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m10))) //m10 loci (hr2)
		destination.addNewDrawnMutation(m10, source.positionsOfMutationsOfType(m10)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m11))) //m11 loci (hcut)
		destination.addNewDrawnMutation(m11, source.positionsOfMutationsOfType(m11)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m12))) //m12 loci (hgap)
		destination.addNewDrawnMutation(m12, source.positionsOfMutationsOfType(m12)[i]);
}
*/

//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	// Representation of the value of the two chromosomes.
	//TARE drive 
	// Check both chromosomes for drive and type 2 resistance allele.
   // These are the only variants that affect fitness.
   TARE_fitness_value = 1.0;
   TARE_drive_on_1 = ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS;
   TARE_drive_on_2 = ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS;
   TARE_res2_on_1 = ind.genome1.countOfMutationsOfType(m4) > 0;
   TARE_res2_on_2 = ind.genome2.countOfMutationsOfType(m4) > 0;
   TARE_wt_1 = ind.genome1.countOfMutationsOfType(m1) > 0;
   TARE_wt_2 = ind.genome2.countOfMutationsOfType(m1) > 0;

   TARE_somatic_fitness_mult = 1;
   if (ind.sex == "F")
       TARE_somatic_fitness_mult = TARE_SOMATIC_FITNESS_MUTLIPLIER_F;
   if (ind.sex == "M")
       TARE_somatic_fitness_mult = TARE_SOMATIC_FITNESS_MUTLIPLIER_M;
   // Check both chromosomes for the drive.
   if (TARE_drive_on_1) {
   	TARE_fitness_value = TARE_DX_FITNESS_VALUE;
      if (TARE_wt_1 | TARE_wt_2)
       	TARE_fitness_value = TARE_fitness_value * TARE_somatic_fitness_mult;
   }
   if (TARE_drive_on_2) {
   	TARE_fitness_value = TARE_DX_FITNESS_VALUE;
   	if (TARE_wt_1 | TARE_wt_2)
   		TARE_fitness_value = TARE_fitness_value * TARE_somatic_fitness_mult;
   }
   if (TARE_drive_on_1 & TARE_drive_on_2)
   	TARE_fitness_value = TARE_DD_FITNESS_VALUE;
   // Return fitness for individual with this genotype.
	
	
	//Homing suppression drive
	// Check both chromosomes for drive and type 2 resistance allele.
	// These are the only variants that affect fitness.
	fitness_value = 1.0;
	drive_on_1 = ind.genome1.countOfMutationsOfType(m8) == NUM_GRNAS;
	drive_on_2 = ind.genome2.countOfMutationsOfType(m8) == NUM_GRNAS;
	res2_on_1 = ind.genome1.countOfMutationsOfType(m10) > 0;
	res2_on_2 = ind.genome2.countOfMutationsOfType(m10) > 0;
	wt_1 = ind.genome1.countOfMutationsOfType(m7) > 0;
	wt_2 = ind.genome2.countOfMutationsOfType(m7) > 0;
	
	somatic_fitness_mult = 1;
	//Only when the individual has TARE drive m2, the cas9 exists and has somatic fitness cost
	if (ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS | ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS){
		if (ind.sex == "F")
			somatic_fitness_mult = SOMATIC_FITNESS_MUTLIPLIER_F;
		if (ind.sex == "M")
			somatic_fitness_mult = SOMATIC_FITNESS_MUTLIPLIER_M;
	}
	
	// Check both chromosomes for the drive.
	if (drive_on_1) {
		fitness_value = DX_FITNESS_VALUE;
		if (wt_1 | wt_2)
			fitness_value = fitness_value * somatic_fitness_mult;
	}
	if (drive_on_2) {
		fitness_value = DX_FITNESS_VALUE;
		if (wt_1 | wt_2)
			fitness_value = fitness_value * somatic_fitness_mult;
	}
	if (drive_on_1 & drive_on_2)
		fitness_value = DD_FITNESS_VALUE;
	
	
	// Return fitness for individual with this genotype.
	return TARE_fitness_value * fitness_value;
}



//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(NULL, "F") {
	// First, evaluate whether reproduction is suppressed by a population suppression drive,
	// Then, select a mate based on fitness, then generate offspring.
	// Suppression drives:
	if (RECESSIVE_FEMALE_STERILE_SUPPRESSION_DRIVE)
		if (isRecessiveSterilitySuppressed(individual))
			return;

	all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
	neighbors = all_neighbors[all_neighbors.sex == "M"];
	if (size(neighbors) == 0) // If no mates are in mate detection range, the female won't mate.
		return;
	attempt_no = 0;
	while (1) {
		// First, select a random potential mate.
		mate_no = 0;
		if (size(neighbors) > 1)
			mate_no = rdunif(1, max=size(neighbors) - 1);
		selected_mate = neighbors[mate_no];
		
		// Determine attractiveness of potential mate.
		mate_attractiveness = genotypeFitness(selected_mate);
		
		// Inbreeding avoidance factor represents the percent decrease in attractiveness of a brother if positive
		// and the percent increase in attractiveness of a brother if negative
		if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
			mate_attractiveness = mate_attractiveness * (1 - INBREEDING_AVOIDANCE_FACTOR);		

		
		// Determine if this mate is chosen, based on attractiveness and number of mates so far.
		if (runif(1) < mate_attractiveness)
			break;
		
		// After twenty candidates fail, female gives up.
		attempt_no = attempt_no + 1;
		if (attempt_no == 19)
			return;
	}
	// Mate has now been selected. 	
	
	// Amount of competition faced per expected competition.
	adult_density_force = i2.totalOfNeighborStrengths(individual);
	competition_ratio = adult_density_force / EXPECTED_ADULT_COMPETITION;
	actual_competition_factor = GROWTH_AT_ZERO_DENSITY/ ((GROWTH_AT_ZERO_DENSITY-1) * competition_ratio + 1);
	
	// Offspring number based on binomial distribution.
	// p for binomial draw. Number of offspring varies with female genes and competition.
	p = genotypeFitness(individual) * actual_competition_factor * 0.04 / (1 + RATE_FEMALES_SURVIVE);
	// Inbreeding fecundity penalty represents a percent decrease in the probability of generating offspring due to inbreeding
	if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
		p = p * (1-INBREEDING_FECUNDITY_PENALTY);
	num_offspring = rbinom(1, 50, p);
	
	//in RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE, males with an r2 or drive on both chromosomes are sterile
	if (RECESSIVE_MALE_STERILE_SUPPRESSION_DRIVE) {
		if (isRecessiveSterilitySuppressed(selected_mate))
			num_offspring = 0;
	}
	
	
	for (i in seqLen(num_offspring)) {
		// Add offspring to the subpopulation.
		offspring = subpop.addCrossed(individual, selected_mate);
		if (!isNULL(offspring)){
			if (REPRISING_BOUNDARIES) {
					// Offspring placement within reprising boundaries.
				if (TWO_DIMENSIONAL) {
					do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				} else {
					// Toroidal world offspring placement.
					do position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				}
			}
			else {
				if (TWO_DIMENSIONAL) {
					position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				} else {
					position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				}
			}
		}
	}
}


//// GENE DRIVE IMPLEMENTATION RULES THAT OCCUR IN EVERY CHILD.
1: modifyChild() {
	// Apply effects that happen in the germline.
	// First, resistance alleles form.
	germline(child.genome1, parent1, GERMLINE_RESISTANCE_RATE_TARE, GERMLINE_RESISTANCE_CUT_RATE_HOM);//GERMLINE_RESISTANCE_CUT_RATE_F_HOM
	germline(child.genome2, parent2, GERMLINE_RESISTANCE_RATE_TARE, GERMLINE_RESISTANCE_CUT_RATE_HOM);//GERMLINE_RESISTANCE_CUT_RATE_M_HOM
	
	// Next, homology directed repair allows for homing to occur.
	hdr(child.genome1, parent1, HOMING_PHASE_CUT_RATE);//HOMING_PHASE_CUT_RATE_F
	hdr(child.genome2, parent2, HOMING_PHASE_CUT_RATE);//HOMING_PHASE_CUT_RATE_M
	
	// Then additional resistance alleles form after hdr in homing suppression drive
	late_germline(child.genome1, parent1, LATE_GERMLINE_RESISTANCE_RATE);
	late_germline(child.genome2, parent2, LATE_GERMLINE_RESISTANCE_RATE);
	
	embryo_TARE(child.genome1, child.genome2, parent1);
	embryo_HOM(child.genome1, child.genome2, parent1, EMBRYO_RESISTANCE_CUT_RATE_HOM);
	
	
	
	
	
	// Offspring may be non viable offspring if drive
	// is haplolethal or haplosufficient recessive lethal.
	num_TARE_drives = sum(child.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	num_HOM_drives = sum(child.genomes.countOfMutationsOfType(m8)==NUM_GRNAS);
	num_TARE_r2 = sum(child.genomes.countOfMutationsOfType(m4) > 0);
	num_HOM_r2 = sum(child.genomes.countOfMutationsOfType(m10) > 0);
	
	// If drive is TARE, offspring is nonviable if it received two r2
	if (num_TARE_r2==2)
		return F;
	return T;
	// If drive is HOM, offspring is all viable. Female is sterile with d/d, d/r2, r2/r2.
}




//// EVALUATING SPATIAL INTERACTIONS BETWEEN INDIVIDUALS FOR OTHER FUNCTIONS.
late() {
	i1.evaluate(sim.subpopulations);
	i2.evaluate(sim.subpopulations);
}

//// SURVIVAL RULES FOR THE SIMULATION BASED ON AGE
late() {
	all = sim.subpopulations.individuals;
	
	//Males don't live past one generation
	all[all.sex=="M"].fitnessScaling = 0.0;
	
	//Females may survive to the next generation at the rate specified by user.
	
	females = all[all.sex=="F"];
	females[females.age > 0].fitnessScaling = 0.0;
	females[females.age==0].fitnessScaling = RATE_FEMALES_SURVIVE;
	
	surviving_inds = all[all.fitnessScaling > 0.0];
	
	// Surviving individuals move
	for (ind in surviving_inds) {
		if (REPRISING_BOUNDARIES) {
			// Movement within reprising boundaries.
			if (TWO_DIMENSIONAL) {
				do position = ind.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
				while (!ind.subpopulation.pointInBounds(position));
				ind.setSpatialPosition(position);
			} else {
				do position = ind.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
				while (!ind.subpopulation.pointInBounds(position));
				ind.setSpatialPosition(position);
			}
		} else {
			// Toroidal world movement.
			if (TWO_DIMENSIONAL) {
				ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
				ind.y = ind.y + rnorm(1, 0, FEMALE_SPEED);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			} else {
				ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			}
		}
	}
}




//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 early() {
	// Start with a population of wild type flies.
	sim.addSubpop("p1", CAPACITY);
	all= p1.individuals;
	all.genomes.addNewDrawnMutation(c(m1, m7), c(0, 1));
	
	// Start individuals scattered at random.
	if (TWO_DIMENSIONAL) {
		all.x = runif(CAPACITY);
		all.y = runif(CAPACITY);
	} else {
		all.x = p1.pointUniform(CAPACITY);
		sim.setValue("timer", "start");
	}
}



//// DROP FIRST GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
11 early(){
	all= p1.individuals;
	i1.evaluate(sim.subpopulations);
	slice_drop_radius=all[i1.distanceFromPoint(c(0.5,0.5),all)<= DROP_RADIUS];// convert the wt individuals in the middle circle to drop individuals 
	//slice_drop_radius=all[(all.x > 0.5 - DROP_RADIUS & all.x <= 0.5 + DROP_RADIUS)&(all.y > 0.5 - DROP_RADIUS & all.y <= 0.5 + DROP_RADIUS)]; // square drop
	slice_drop_radius_size=length(slice_drop_radius);
	catn("###################"+slice_drop_radius_size);
	// Add a drop of modified individuals to p1.
	if (DROP_ADDS_TO_POP){
		size_of_drop = asInteger(p1.individualCount / 2 * DROP_PERCENTAGE_OVERRIDE_TARE / (1 - DROP_PERCENTAGE_OVERRIDE_TARE));
		sim.addSubpop("p2", size_of_drop);
		drop1 = p2.individuals;
	}
	
	if (!DROP_ADDS_TO_POP) {
		size_of_drop = asInteger(slice_drop_radius_size * DROP_PERCENTAGE_OVERRIDE_TARE);
		drop1 = sample(slice_drop_radius, size_of_drop);
	}
	
	// Now set the drop individuals to the correct genotypes:
	drop1.genomes.addNewDrawnMutation(c(m2, m7), c(0, 1));
	
	// Move all the individuals from the drop into p1:
	p1.takeMigrants(drop1);
	//drop1.x = runif(size_of_drop, 0, DROP_RADIUS);
	
	/*
	if (TWO_DIMENSIONAL) {
		if (LEFT_EDGE_DROP) { // Left-rectangle drop
			drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
			drop.y = runif(DROP_SIZE);
		} else if (CIRCLE_DROP) { // Default circle drop
			drop.x = 0.5 + rnorm(DROP_SIZE, 0, DROP_RADIUS);
			drop.y = 0.5 + rnorm(DROP_SIZE, 0, DROP_RADIUS);
		} else if (UNIFORM_DROP) { // Scattered uniformly
			drop.x = runif(DROP_SIZE);
			drop.y = runif(DROP_SIZE);
		} else if (CORNER_DROP) {
			for (ind in drop) {
				ind.x = rnorm(1, 0, DROP_RADIUS);
				ind.y = rnorm(1, 0, DROP_RADIUS);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			}
		}
	
	}
	*/
	if (DROP_ADDS_TO_POP){
		p2.removeSubpopulation();
	}
}

//// DROP SECOND GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
11: early(){
	all = p1.individuals;
	i1.evaluate(sim.subpopulations);
	this_gen=sim.cycle-10;
	x=EMBRYO_RESISTANCE_CUT_RATE_HOM;
	y=HOMING_PHASE_CUT_RATE;
	MIGRATION_CALIBRATION=AVERAGE_DISTANCE/0.05;
	HOMS_DRIVE_PREDICTION=1.4179152 *x^2+ 97.13937583*y^ 2+(-57.18654073)*x*y+63.17415204*x+(-176.77461292 )*y+87.88307748;
	drop_gen=asInteger(round(3+((TARE_DRIVE_PREDICTION-HOMS_DRIVE_PREDICTION)/MIGRATION_CALIBRATION)));//TARE will be eaten by HOMS, so add 3 more generations to cushion.
	if (drop_gen<=1){
	drop_gen=1;
	}

	/*
	//Middle test 
	target=all[all.countOfMutationsOfType(m2)!=0];
	all_middle = all[i1.distanceFromPoint(c(0.5,0.5),all) > 0.225 & i1.distanceFromPoint(c(0.5,0.5),all) <= 0.275];
	all_middle_number = length(all_middle);
	target_middle = target[i1.distanceFromPoint(c(0.5,0.5),target) > 0.225 & i1.distanceFromPoint(c(0.5,0.5),target) <= 0.275];
	target_middle_number = length(target_middle);
	percentage = target_middle_number/all_middle_number;
	catn("MIDDLE_FREQUENCY:: "+this_gen+" "+percentage);
	if (percentage >= 0.5){
		middle_gen = sim.getValue("middle_gen");
		if (isNULL(sim.getValue("middle_gen"))){
			sim.setValue("middle_gen",this_gen);
			middle_gen = sim.getValue("middle_gen");
			catn("MIDDLE_ANALYSIS:: "+ middle_gen+" "+percentage);
			sim.simulationFinished();
		}
	}
	*/
	
		/*
	//Middle test 1
	target_1=all[all.countOfMutationsOfType(m8)!=0];
	all_middle = all[i1.distanceFromPoint(c(0.5,0.5),all) > 0.225 & i1.distanceFromPoint(c(0.5,0.5),all) <= 0.275];
	all_middle_number = length(all_middle);
	target_middle_1 = target_1[i1.distanceFromPoint(c(0.5,0.5),target_1) > 0.225 & i1.distanceFromPoint(c(0.5,0.5),target_1) <= 0.275];
	target_middle_number_1 = length(target_middle_1);
	percentage_1 = target_middle_number_1/all_middle_number;
	catn("MIDDLE_FREQUENCY_1:: "+this_gen+" "+percentage_1);
	if (percentage_1 >= 0.5){
		middle_gen_1 = sim.getValue("middle_gen_1");
		if (isNULL(sim.getValue("middle_gen_1"))){
			sim.setValue("middle_gen_1",this_gen);
			middle_gen_1 = sim.getValue("middle_gen_1");
			catn("MIDDLE_ANALYSIS:: "+ middle_gen_1+" "+percentage_1);
			sim.simulationFinished();
		}
	}
	*/

	if (this_gen==drop_gen){
		slice_drop_radius=all[i1.distanceFromPoint(c(0.5,0.5),all)<= DROP_RADIUS];// convert the wt individuals in the middle circle to drop individuals 
		slice_drop_radius_size=length(slice_drop_radius);
		// Add a drop of modified individuals to p1.
		if (DROP_ADDS_TO_POP){
			size_of_drop = asInteger(p1.individualCount / 2 * DROP_PERCENTAGE_OVERRIDE_HOM / (1 - DROP_PERCENTAGE_OVERRIDE_HOM));
			sim.addSubpop("p3", size_of_drop);
			drop2 = p3.individuals;
		}
	
		if (!DROP_ADDS_TO_POP) {
			size_of_drop = asInteger(slice_drop_radius_size * DROP_PERCENTAGE_OVERRIDE_HOM);
			drop2 = sample(slice_drop_radius, size_of_drop);
		}
	
		// Now set the drop individuals to the correct genotypes:
		drop2.genomes.addNewDrawnMutation(c(m2, m8), c(0, 1));
		drop2.genome2.addNewDrawnMutation(c(m2, m7), c(0, 1));
	
		// Move all the individuals from the drop into p1:
		p1.takeMigrants(drop2);
		//drop2.x = runif(size_of_drop, 0, DROP_RADIUS);
	
		if (DROP_ADDS_TO_POP){
			p3.removeSubpopulation();
		}
		if (TRACK_BY_CELL)
			sim.setValue("start_gc_tracking", F); //don't start until number of wt alleles falls below 80% eq
	}
}

//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
	all = sim.subpopulations.individuals;
	all.color = "blue"; // wt individuals are blue
	all[all.countOfMutationsOfType(m1) == 2 & all.countOfMutationsOfType(m7) == 2].color = "blue";
	all[all.countOfMutationsOfType(m2) >= NUM_GRNAS & all.countOfMutationsOfType(m8) == 0].color = "red"; // only_TARE_carrying
	all[all.countOfMutationsOfType(m8) >= NUM_GRNAS & all.countOfMutationsOfType(m2) == 0].color = "green"; // only_HOM_carrying
	all[all.countOfMutationsOfType(m2) >= NUM_GRNAS & all.countOfMutationsOfType(m8) >= NUM_GRNAS].color = "yellow";// TARE_HOM_carrying	
}

//// PROGRAM OUTPUT.
1:late() {
	// Population size
	all = sim.subpopulations.individuals;
	this_gen=sim.cycle-10;
	pop_size = length(all);
	males = all[all.sex=="M"];
	num_males = length(males);
	females = all[all.sex=="F"];
	num_females = length(females);
	num_fertile_females = sum(females.genomes.countOfMutationsOfType(m7)>0 | females.genomes.countOfMutationsOfType(m9)>0);
	catn("THIS_GEN:: "+this_gen);
	catn("POP_SIZE:: "+pop_size);
	catn("FERTILE_FEMALE:: "+num_fertile_females);
	x=EMBRYO_RESISTANCE_CUT_RATE_HOM;
	y=HOMING_PHASE_CUT_RATE;
	MIGRATION_CALIBRATION=AVERAGE_DISTANCE/0.05;
	HOMS_DRIVE_PREDICTION=1.4179152 *x^2+ 97.13937583*y^ 2+(-57.18654073)*x*y+63.17415204*x+(-176.77461292 )*y+87.88307748;
	drop_gen=asInteger(round(3+((TARE_DRIVE_PREDICTION-HOMS_DRIVE_PREDICTION)/MIGRATION_CALIBRATION)));//TARE will be eaten by HOMS, so add 3 more generations to cushion.
	if (drop_gen<=1){
	drop_gen=1;
	}
	
	catn("TARE_DRIVE_PREDICTION:: "+TARE_DRIVE_PREDICTION);
	catn("HOMS_DRIVE_PREDICTION:: "+HOMS_DRIVE_PREDICTION);
	catn("HOMS_DROP_GEN:: "+drop_gen);

	catn("HOMS_EMBRYO_CUT:: "+ EMBRYO_RESISTANCE_CUT_RATE_HOM);
	catn("HOMS_CONVERSION_RATE:: "+ HOMING_PHASE_CUT_RATE);
	catn("LOW_DENSITY_GROWTH_RATE:: "+ GROWTH_AT_ZERO_DENSITY);
	catn("AVERAGE_DISTANCE:: "+ AVERAGE_DISTANCE);
	catn("TARE_DD_FITNESS_VALUE:: "+ TARE_DD_FITNESS_VALUE);
	catn("SOMATIC_FITNESS_MUTLIPLIER:: "+ SOMATIC_FITNESS_MUTLIPLIER);
	
	//Count of chromosomes
	num_y = num_males;
	num_x = 2*num_females + num_males;
	num_autosomal_chromosomes = 2*pop_size;
	
	//Allele counts
	num_wt = sum(all.genomes.countOfMutationsOfType(m1)==NUM_GRNAS);
	num_dr = sum(all.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	num_r1 = sum(all.genomes.countOfMutationsOfType(m3)==NUM_GRNAS);
	num_r2 = sum(all.genomes.countOfMutationsOfType(m4)==NUM_GRNAS);
	num_m5 = sum(all.genomes.countOfMutationsOfType(m5)==NUM_GRNAS);
	num_m6 = sum(all.genomes.countOfMutationsOfType(m6)==NUM_GRNAS);

	num_hwt = sum(all.genomes.countOfMutationsOfType(m7)==NUM_GRNAS);
	num_hdr = sum(all.genomes.countOfMutationsOfType(m8)==NUM_GRNAS);
	num_hr1 = sum(all.genomes.countOfMutationsOfType(m9)==NUM_GRNAS);
	num_hr2 = sum(all.genomes.countOfMutationsOfType(m10)==NUM_GRNAS);
	num_m11 = sum(all.genomes.countOfMutationsOfType(m11)==NUM_GRNAS);
	num_m12 = sum(all.genomes.countOfMutationsOfType(m12)==NUM_GRNAS);
	num_has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	rate_has_drive = num_has_drive/pop_size;
	num_has_hdrive = sum(all.countOfMutationsOfType(m8) >= NUM_GRNAS);
	rate_has_hdrive = num_has_hdrive/pop_size;
	
	
	// rate calculations
	rate_dr = num_dr/ num_autosomal_chromosomes;
	rate_wt = num_wt/ num_autosomal_chromosomes;
	rate_r1 = num_r1/num_autosomal_chromosomes;
	rate_r2 = num_r2/num_autosomal_chromosomes;
	rate_m5 = num_m5/num_autosomal_chromosomes;
	rate_m6 = num_m6/num_autosomal_chromosomes;
	rate_hdr = num_hdr/ num_autosomal_chromosomes;
	rate_hwt = num_hwt/ num_autosomal_chromosomes;
	rate_hr1 = num_hr1/num_autosomal_chromosomes;
	rate_hr2 = num_hr2/num_autosomal_chromosomes;
	rate_m11 = num_m11/num_autosomal_chromosomes;
	rate_m12 = num_m12/num_autosomal_chromosomes;
	
	catn("CONFINED_DRIVE_FREQUENCY:: "+rate_dr);
	catn("SUPPRESSION_DRIVE_FREQUENCY:: "+rate_hdr);
	catn(this_gen+"	"+pop_size+"	"+"TARE"+"	"+rate_has_drive+"	"+rate_dr+"	"+rate_wt+"	"+rate_r2+"	"+rate_r1+"	"+rate_m5+"	"+rate_m6+"	"+"HOM"+"	"+rate_has_hdrive+"	"+rate_hdr+"	"+rate_hwt+"	"+rate_hr2+"	"+rate_hr1+"	"+rate_m11+"	"+rate_m12);


	if (this_gen>=drop_gen){

	//SLICE RECORD
	n=0;
//	first=all[all.countOfMutationsOfType(m2)!=0];
//	fx=first.x;
	do{
		first=all[all.countOfMutationsOfType(m2)!=0];
		fx=first.x;
		first_x1=(fx>(n/100))&(fx<=((n+1)/100));
		first_1=first[first_x1];
		num_first_1=length(first_1);
		num_first_allele_1=sum(first_1.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
		second=all[all.countOfMutationsOfType(m8)!=0];
		sx=second.x;
		second_x1=(sx>(n/100))&(sx<=((n+1)/100));
		second_1=second[second_x1];
		num_second_1=length(second_1);
		num_second_allele_1=sum(second_1.genomes.countOfMutationsOfType(m8)==NUM_GRNAS);
		all_x1=(all.x>(n/100))&(all.x<=((n+1)/100));
		all_1=all[all_x1];
		num_all_1=length(all_1);
		wt=all[all.countOfMutationsOfType(m1)==2];	
		wt_x1=(wt.x>(n/100))&(wt.x<=((n+1)/100));
		wt_1=wt[wt_x1];
		num_wt_1	=length(wt_1);
		num_wt_allele_1=sum(all_1.genomes.countOfMutationsOfType(m1)==NUM_GRNAS);
		dwt=all[all.countOfMutationsOfType(m1)==2 & all.countOfMutationsOfType(m7)==2];	
		dwt_x1=(dwt.x>(n/100))&(dwt.x<=((n+1)/100));
		dwt_1=dwt[dwt_x1];
		num_dwt_1 =length(dwt_1);
		hwt=all[all.countOfMutationsOfType(m7)==2];	
		hwt_x1=(hwt.x>(n/100))&(hwt.x<=((n+1)/100));
		hwt_1=hwt[hwt_x1];
		num_hwt_1 =length(hwt_1);
		num_hwt_allele_1=sum(all_1.genomes.countOfMutationsOfType(m7)==NUM_GRNAS);
		n=n+1;
		catn("SLICE:: "+n+" "+num_first_1+" "+num_first_allele_1+" "+num_second_1+" "+num_second_allele_1+" "+num_wt_1+" "+num_wt_allele_1+" "+num_hwt_1+" "+num_hwt_allele_1+" "+num_dwt_1+" "+num_all_1+" "+pop_size);
		
	}while(n<100);		
				/*
		if(any((all.x>(n/20))&(all.x<=((n+1)/20)))){
			if (any((fx<=(n+1)/20)&(fx>(n/20)))){
				//first=all[all.countOfMutationsOfType(m2)!=0];
				//fx=first.x;
				first_x1=(fx>(n/20))&(fx<=((n+1)/20));
				first_1=first[first_x1];
				num_first_1=length(first_1);
				num_first_allele_1=sum(first_1.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
				all_x1=(all.x>(n/20))&(all.x<=((n+1)/20));
				all_1=all[all_x1];
				num_all_1=length(all_1);
				
				catn("SLICE"+n+"="+num_first_1+" "+num_first_allele_1+" "+num_all_1);
				n=n+1;
				
			}
			else{
				n=n+1;
				catn("SLICE:"+n+"=0");
			}
		}
		else{
			n=n+1;
			catn("SLICE"+n+"=N/A");
		}
		*/
	
	//Modification detection
	catn("MODIFICATION:: ");
	/*
	// 2D MIDDLE ANALYSIS
	//MIDDLE ANALYSIS--First drive
	target=all[all.countOfMutationsOfType(m2)!=0];
	target_middle=target[(i1.distanceFromPoint(c(0.5,0.5),target)>= 0.225) & (i1.distanceFromPoint(c(0.5,0.5),target)<= 0.275)];
	target_middle_size=length(target_middle);
	all_middle=all[(i1.distanceFromPoint(c(0.5,0.5),all)>= 0.225) & (i1.distanceFromPoint(c(0.5,0.5),all)<= 0.275)];
	all_middle_size=length(all_middle);
	percentage_of_target_middle=target_middle_size/all_middle_size;
	catn("MIDDLE_FREQUENCY:: "+this_gen+" "+percentage_of_target_middle);

	
	if (percentage_of_target_middle >= 0.5){
		middle_gen = sim.getValue("middle_gen");
		if (isNULL(sim.getValue("middle_gen"))){
			sim.setValue("middle_gen",this_gen);
			middle_gen = sim.getValue("middle_gen");
			catn("MIDDLE_ANALYSIS:: "+ middle_gen+" "+percentage_of_target_middle);
			//sim.simulationFinished();
		}
	}
	
	
	//MIDDLE ANALYSIS--second drive
	target_1=all[all.countOfMutationsOfType(m8)!=0];
	target_1_middle=target_1[(i1.distanceFromPoint(c(0.5,0.5),target_1)>= 0.225) & (i1.distanceFromPoint(c(0.5,0.5),target_1)<= 0.275)];
	target_1_middle_size=length(target_1_middle);
	all_middle=all[(i1.distanceFromPoint(c(0.5,0.5),all)>= 0.225) & (i1.distanceFromPoint(c(0.5,0.5),all)<= 0.275)];
	all_middle_size=length(all_middle);
	percentage_of_target_1_middle=target_1_middle_size/all_middle_size;
	catn("MIDDLE_1_FREQUENCY:: "+this_gen+" "+percentage_of_target_1_middle);
	
	if (percentage_of_target_1_middle >= 0.5){
		middle_1_gen = sim.getValue("middle_1_gen");
		if (isNULL(sim.getValue("middle_1_gen"))){
			sim.setValue("middle_1_gen",this_gen);
			middle_1_gen = sim.getValue("middle_1_gen");
			catn("MIDDLE_1_ANALYSIS:: "+ middle_1_gen+" "+percentage_of_target_1_middle);
			//sim.simulationFinished();
		}
	}	
	*/
	
	// Chasing analysis:
	
	// First, check whether the number of wild-type alleles has decreased at least
	// 20% from its equilibrium value.
	if (num_wt < EQUILIBRIUM_WT_ALLELE_THRESHOLD) {
		catn("CONFINED_POTENTIAL_CHASE:: " + this_gen);
		
		if (!sim.getValue("start_gc_tracking"))
			sim.setValue("start_gc_tracking", T); // Start measuring Green's coefficient
	}
	
	// 2D-specific detection:
	if (TWO_DIMENSIONAL) {
		
		// Output for Python 
		if (NO_DROP)
			sim.setValue("start_gc_tracking", T); // Start tracking Green's coefficient immediately if only wts
		else {
			catn("CONFINED_GEN: "+this_gen+" RATE_DR: " + rate_dr);
		}
		
		// Record quadrant counts to calculate Green's coefficient
		if (sim.getValue("start_gc_tracking")) {
			nondrive = all[all.countOfMutationsOfType(m2) == 0];
			nonx = nondrive.x;
			nony = nondrive.y;
			allx = all.x;
			ally = all.y;
			pos_vec = 0:(sqrt(NUMBER_OF_CELLS) - 1);
			dim = length(pos_vec);
			cell_width = 1.0/dim;
			positions = pos_vec * cell_width;
			nondrive_track = c();
			all_track = c();
			
			for (i in 0:(dim-1)) {
				div_left = positions[i];
				for (j in 0:(dim-1)) {
					div_bot = positions[j];
					
					nondrive_in_division = (nonx >= div_left) & (nonx < (div_left + cell_width)) & (nony >= div_bot) & (nony < (div_bot + cell_width));
					nondrive_in_cell = nondrive[nondrive_in_division];
					nondrive_cell_count = size(nondrive_in_cell);
					nondrive_track = c(nondrive_track, nondrive_cell_count);
					
					all_in_division = (allx >= div_left) & (allx < (div_left + cell_width)) & (ally >= div_bot) & (ally < (div_bot + cell_width));
					all_in_cell = all[all_in_division];
					all_cell_count = size(all_in_cell);
					all_track = c(all_track, all_cell_count);
				}
			}
			
			nondrive_pop_size = sum(nondrive_track); // Number of wts
			
			// Prevent nan-error issues
			if (nondrive_pop_size > 1) {
				nondrive_greens_coeff = (var(nondrive_track)/mean(nondrive_track) - 1)/(sum(nondrive_track) - 1);
				all_greens_coeff = (var(all_track)/mean(all_track) - 1)/(sum(all_track)-1);
				
				// (1) number wt alleles (2) generation (3) population size (5) Green's coefficient of wts for chase detection (7) Green's coefficient of all individuals 
				catn("CONFINED_WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + nondrive_greens_coeff + " " + "OVERALL_GC::" + " " +all_greens_coeff+" " +rate_has_drive);
			}
		}
		
	// 1-D specific detection:
	} else {
		
		//time from one side of the landscape to the other
		timer = sim.getValue("timer");
	
		//only start timer once
		//skip over this once once the timer has been stopped
		if (timer!="stopped") {
			all_x = all.x;
			at_start = (all_x >= 0.25) & (all_x <= 0.3);
			inds_start = all[at_start];
		
			if (size(inds_start) <= EQUILIBRIUM_BIN_POPULATION) {
				if (timer=="start") {
					catn("starting timer at " + this_gen);
					sim.setValue("timer", this_gen);
				}
			}
			at_end = (all_x >= 0.75) & (all_x <= 0.8);
			inds_end = all[at_end];
		
			if (size(inds_end) <= EQUILIBRIUM_BIN_POPULATION) {
				if (timer!= "start") {
					start_gen = sim.getValue("timer");
					gens_elapsed = this_gen - start_gen;
					catn("stopping timer at " + this_gen);
					catn("CONFINED_TIMED_GENS:: " + gens_elapsed);
					sim.setValue("timer", "stopped"); //stop tracking this 
				}
			}
		}
	
		if (TRACK_BY_CELL)  {
			//only start recording once the number of WT alleles first falls below 80% of equilibrium
			inds = all[all.countOfMutationsOfType(m2) == 0]; //non drive individuals
			x = inds.x;
			pos_vec = 0:(NUMBER_OF_CELLS - 1);
			dim = length(pos_vec);
			cell_width = 1.0/dim;
			positions = pos_vec * cell_width;
		
			gen_track = c(); //record all cell counts for THIS generation
		
		
			for (i in 0:(dim-1)) {
				div_left = positions[i];
				in_division = (x >= div_left) & (x < (div_left + cell_width));
				inds_in_cell = inds[in_division];
				cell_count = size(inds_in_cell);
				if ((length(gen_track) > 0)) {
					if ((cell_count < 10) & sum(gen_track) > 50)
						catn("CONFINED_CHASE_GEN:: " + this_gen);
				}
				gen_track = c(gen_track, cell_count);
			}
		
			//Green's Coefficient is a measure of clustering for this generation
			//when individuals are completely randomly distributed, GC = 0. 
			//when individuals are as clustered as possible, GC = 1.
			pop_size = sum(gen_track);
		
			//prevent nan errors
			if (pop_size > 1) {
				greens_coeff = (var(gen_track)/mean(gen_track) - 1)/(sum(gen_track) - 1);
				catn("CONFINED_WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + greens_coeff+" "+rate_has_drive);
			}
		}
		// record drive thickness and then average from 5 generations after the drop 
		// to the (chasing_gen - 5) if chasing occurred or the (suppression_gen - 5)
		// if chasing didn't occur
		if (this_gen >= 5) {
			has_drive = all.countOfMutationsOfType(m2)>=NUM_GRNAS;
			drive_inds = all[has_drive].x;
			if (size(drive_inds) > 0) {
				thickness = max(drive_inds) - min(drive_inds);
				catn("CONFINED_THICKNESS:: " + thickness);
			}
		}
	}
	
	if (NO_DROP)
		return;
	
	
	//catn(num_dr);
	
	////2-drive was successful
	if (rate_has_drive == 1 & pop_size>=0) {
		catn("CONFINED_DRIVE_SUCCESS:: " + this_gen);
	}	
	
	//1-drive was lost and wt population remained
	if (num_dr == 0){
		last_ten_gen = sim.getValue("last_ten_gen");
		//catn(last_ten_gen);
		
		if (isNULL(sim.getValue("last_ten_gen"))){
			
			//catn(type(isNULL(sim.getValue("last_ten_gen"))));
			sim.setValue("last_ten_gen",this_gen);
			//sim.setValue("last_ten_gen", "stopped");
		}
		
		last_ten_gen_start = sim.getValue("last_ten_gen");
		//catn(last_ten_gen_start);
		//catn(this_gen);
		//catn(type(last_ten_gen_start));
		//catn(type(this_gen));
		a=asInteger(this_gen);
		b=asInteger(last_ten_gen_start);
		gens_last=a-b;
		//catn(gens_last);
		if (gens_last < 10){
			if (pop_size == 0){
				catn("SUPPRESSED:: " + this_gen);
				sim.simulationFinished();
			}
		}
		if (gens_last == 10){
			catn("CONFINED_DRIVE_LOST:: " + last_ten_gen_start);
			sim.simulationFinished();
		}		
	}
	
	
	

	
	//3-resistance allele formation
	if (num_r1 >= 0.2*CAPACITY) {
		catn("CONFINED_RESISTANCE:: " + this_gen);
		sim.simulationFinished();
	}
	
	//Suppression detection
	catn("SUPPRESSION:: ");
	
// Chasing analysis:
	
	// First, check whether the number of wild-type alleles has decreased at least
	// 20% from its equilibrium value.
	if (num_hwt < EQUILIBRIUM_WT_ALLELE_THRESHOLD) {
		catn("SUPPRESSION_POTENTIAL_CHASE:: " + this_gen);
		
		if (!sim.getValue("start_gc_tracking"))
			sim.setValue("start_gc_tracking", T); // Start measuring Green's coefficient
	}
	
	// 2D-specific detection:
	if (TWO_DIMENSIONAL) {
		
		// Output for Python 
		if (NO_DROP)
			sim.setValue("start_gc_tracking", T); // Start tracking Green's coefficient immediately if only wts
		else {
			catn("SUPPRESSION_GEN: "+this_gen+" RATE_DR: " + rate_dr);
		}
		
		// Record quadrant counts to calculate Green's coefficient
		if (sim.getValue("start_gc_tracking")) {
			nondrive = all[all.countOfMutationsOfType(m8) == 0];
			nonx = nondrive.x;
			nony = nondrive.y;
			allx = all.x;
			ally = all.y;
			pos_vec = 0:(sqrt(NUMBER_OF_CELLS) - 1);
			dim = length(pos_vec);
			cell_width = 1.0/dim;
			positions = pos_vec * cell_width;
			nondrive_track = c();
			all_track = c();
			
			for (i in 0:(dim-1)) {
				div_left = positions[i];
				for (j in 0:(dim-1)) {
					div_bot = positions[j];
					
					nondrive_in_division = (nonx >= div_left) & (nonx < (div_left + cell_width)) & (nony >= div_bot) & (nony < (div_bot + cell_width));
					nondrive_in_cell = nondrive[nondrive_in_division];
					nondrive_cell_count = size(nondrive_in_cell);
					nondrive_track = c(nondrive_track, nondrive_cell_count);
					
					all_in_division = (allx >= div_left) & (allx < (div_left + cell_width)) & (ally >= div_bot) & (ally < (div_bot + cell_width));
					all_in_cell = all[all_in_division];
					all_cell_count = size(all_in_cell);
					all_track = c(all_track, all_cell_count);
				}
			}
			
			nondrive_pop_size = sum(nondrive_track); // Number of wts
			
			// Prevent nan-error issues
			if (nondrive_pop_size > 1) {
				nondrive_greens_coeff = (var(nondrive_track)/mean(nondrive_track) - 1)/(sum(nondrive_track) - 1);
				all_greens_coeff = (var(all_track)/mean(all_track) - 1)/(sum(all_track)-1);
				
				// (1) number wt alleles (2) generation (3) population size (5) Green's coefficient of wts for chase detection (7) Green's coefficient of all individuals 
				catn("SUPPRESSION_WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + nondrive_greens_coeff + " " + "OVERALL_GC::" + " " +all_greens_coeff+" " +rate_has_hdrive);
			}
		}
	
	// 1-D specific detection:
	} else {
		
		//time from one side of the landscape to the other
		timer = sim.getValue("timer");
	
		//only start timer once
		//skip over this once once the timer has been stopped
		if (timer!="stopped") {
			all_x = all.x;
			at_start = (all_x >= 0.25) & (all_x <= 0.3);
			inds_start = all[at_start];
		
			if (size(inds_start) <= EQUILIBRIUM_BIN_POPULATION) {
				if (timer=="start") {
					catn("starting timer at " + this_gen);
					sim.setValue("timer", this_gen);
				}
			}
			at_end = (all_x >= 0.75) & (all_x <= 0.8);
			inds_end = all[at_end];
		
			if (size(inds_end) <= EQUILIBRIUM_BIN_POPULATION) {
				if (timer!= "start") {
					start_gen = sim.getValue("timer");
					gens_elapsed = this_gen - start_gen;
					catn("stopping timer at " + this_gen);
					catn("SUPPRESSED_TIMED_GENS:: " + gens_elapsed);
					sim.setValue("timer", "stopped"); //stop tracking this 
				}
			}
		}
	
		if (TRACK_BY_CELL)  {
			//only start recording once the number of WT alleles first falls below 80% of equilibrium
			inds = all[all.countOfMutationsOfType(m8) == 0]; //non drive individuals
			x = inds.x;
			pos_vec = 0:(NUMBER_OF_CELLS - 1);
			dim = length(pos_vec);
			cell_width = 1.0/dim;
			positions = pos_vec * cell_width;
		
			gen_track = c(); //record all cell counts for THIS generation
		
		
			for (i in 0:(dim-1)) {
				div_left = positions[i];
				in_division = (x >= div_left) & (x < (div_left + cell_width));
				inds_in_cell = inds[in_division];
				cell_count = size(inds_in_cell);
				if ((length(gen_track) > 0)) {
					if ((cell_count < 10) & sum(gen_track) > 50)
						catn("SUPPRESSION_CHASE_GEN:: " + this_gen);
				}
				gen_track = c(gen_track, cell_count);
			}
		
			//Green's Coefficient is a measure of clustering for this generation
			//when individuals are completely randomly distributed, GC = 0. 
			//when individuals are as clustered as possible, GC = 1.
			pop_size = sum(gen_track);
		
			//prevent nan errors
			if (pop_size > 1) {
				greens_coeff = (var(gen_track)/mean(gen_track) - 1)/(sum(gen_track) - 1);
				catn("SUPPRESSION_WT_ALLELES:: " + num_hwt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + greens_coeff+" "+rate_has_hdrive);
			}
		}
		// record drive thickness and then average from 5 generations after the drop 
		// to the (chasing_gen - 5) if chasing occurred or the (suppression_gen - 5)
		// if chasing didn't occur
		if (this_gen >= 5) {
			has_drive = all.countOfMutationsOfType(m8)>=NUM_GRNAS;
			drive_inds = all[has_drive].x;
			if (size(drive_inds) > 0) {
				thickness = max(drive_inds) - min(drive_inds);
				catn("SUPPRESSION_THICKNESS:: " + thickness);
			}
		}
	}
	
	if (NO_DROP)
		return;
	
	//1-drive was lost and wt population remained
	if (num_hdr == 0){
		last_ten_gen_2 = sim.getValue("last_ten_gen_2");

		
		if (isNULL(sim.getValue("last_ten_gen_2"))){

			sim.setValue("last_ten_gen_2",this_gen);
		}
		
		last_ten_gen_start_2 = sim.getValue("last_ten_gen_2");

		c=asInteger(this_gen);
		d=asInteger(last_ten_gen_start_2);
		gens_last_2=c-d;

		if (gens_last_2 < 10){
			if (pop_size == 0){
				catn("SUPPRESSED:: " + this_gen);
				sim.simulationFinished();
			}
		}
		if (gens_last_2== 10){
			catn("SUPPRESSION_DRIVE_LOST:: " + last_ten_gen_start_2);
			sim.simulationFinished();
		}		
	}
	
	//2-population was eliminated
	if (pop_size==0) {
		catn("SUPPRESSED:: " + this_gen);
		sim.simulationFinished();
	}
	//3-resistance allele formation
	if (num_hr1 >= 0.2*CAPACITY) {
		catn("SUPPRESSION_RESISTANCE:: " + this_gen);
		sim.simulationFinished();
	}
	
	
	
	
	
	////catn(this_gen+"	"+pop_size+"	"+rate_has_hdrive+"	"+rate_hdr+"	"+rate_hwt+"	"+rate_hr2);
	catn(this_gen+"	"+pop_size+"	"+"TARE"+"	"+rate_has_drive+"	"+rate_dr+"	"+rate_wt+"	"+rate_r2+"	"+rate_r1+"	"+rate_m5+"	"+rate_m6+"	"+"HOM"+"	"+rate_has_hdrive+"	"+rate_hdr+"	"+rate_hwt+"	"+rate_hr2+"	"+rate_hr1+"	"+rate_m11+"	"+rate_m12);
}

}

//// PROGRAM END CONDITION.
1000 late() {
	all = sim.subpopulations.individuals;
	pop_size = length(all);
	num_has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	rate_has_drive = num_has_drive/pop_size;
	num_has_hdrive = sum(all.countOfMutationsOfType(m8) >= NUM_GRNAS);
	rate_has_hdrive = num_has_hdrive/pop_size;
	catn("TARE_DRIVE_EFFICIENCY:: "+ GERMLINE_RESISTANCE_RATE_TARE);
	catn("TARE_EMBRYO_CUT:: "+ EMBRYO_RESISTANCE_RATE_TARE);
	catn("HOMING_CONVERSION_RATE:: "+ HOMING_PHASE_CUT_RATE);
	catn("HOMING_EMBRYO_CUT:: "+ EMBRYO_RESISTANCE_CUT_RATE_HOM);
	catn("FITNESS:: "+ DD_FITNESS_VALUE);	 
	catn("GROWTH:: "+ GROWTH_AT_ZERO_DENSITY);
	catn("TIMED_GENS: 1000");
	catn("ENDING_AFTER_1000:: " + rate_has_drive+" "+rate_has_hdrive);
	sim.simulationFinished();
}
