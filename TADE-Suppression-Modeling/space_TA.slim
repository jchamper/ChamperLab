// Author: Sam Champer and Yutong Zhu.
// Created in association with Jackson Champer and the Messer lab.

// A framework for simulating many different gene drives
// with varying parameters, intended to be configured by
// alterning the heading below, or by dynamically varying
// values in the header using an associated Python file.

// This version starts with a wild population,
// allows the population to equilibrate over 10 generations,
// and then drops transgenic individuals into the population 
// or modifies the pre-existing individuals and turns them into drive individuals.

// The following header to be replaced via python,
// such that these values can be varied across multiple runs of slim.
initialize() {
    // Configure whether or not spatial data is exported to be turned into a movie.
    defineCfgParam("OUTPUT_SPATIAL_DATA", F);  // Note: this makes the simulation much slower.
    defineCfgParam("OUTFILE", "slim_movie");


    // Fitness parameters:
    defineCfgParam("DRIVE_FITNESS_VALUE", 1.0);
    defineCfgParam("R2_FITNESS_VALUE", 1.0);

    // Drive type:
    defineCfgParam("MUTUAL_TARGETING_DRIVE", F);  // Drive at x targets x+1. Drive at extreme targets site 0.
    defineCfgParam("SELF_TARGETING_DRIVE", F);  // Drive cuts at the same site.
    defineCfgParam("SITE_ZERO_NON_TARGETED", T);  // There are NUM_LOCI - 1 total drives. Drive at zero is not a resistance target.
    defineCfgParam("SITE_ZERO_RECESSIVE_FEMALE_STERILE", T);  // Drive at locus zero targets female recessive sterility.
    defineCfgParam("SITE_ZERO_RECESSIVE_MALE_STERILE", F);  // Drive at locus zero targets male recessive sterility.
    defineCfgParam("DOUBLE_TOXINS", F);
    defineCfgParam("STERILE_MALE", F);  // Not actually a drive.

    // General drive parameters:
    defineCfgParam("NUM_LOCI", 2);
    defineCfgParam("X_LINKED", F);
    defineCfgParam("MALE_ONLY_PROMOTER", F);

    // Resistance effects:
    defineCfgParam("TADE_LETHAL", T);
    defineCfgParam("TARE_LETHAL", F);
    defineCfgParam("TADDE_LETHAL", F);
    defineCfgParam("TAHRE_LETHAL", F);
    defineCfgParam("FEMALE_TADE_STERILE", T);
    defineCfgParam("FEMALE_TARE_STERILE", F);
    defineCfgParam("FEMALE_TADDE_STERILE", F);
    defineCfgParam("FEMALE_TAHRE_STERILE", F);
    defineCfgParam("MALE_TADE_STERILE", F);
    defineCfgParam("MALE_TARE_STERILE", F);
    defineCfgParam("MALE_TADDE_STERILE", F);
    defineCfgParam("MALE_TAHRE_STERILE", F);
    defineCfgParam("TADEV", F);  // Drive is viabile, but individuals incur a fitness penalty.
    defineCfgParam("TAREV", F);
    defineCfgParam("TADDEV", F);
    defineCfgParam("TAHREV", F);
    defineCfgParam("TA_RESISTANCE_FITNESS_MULTIPLIER", 1.0);
    defineCfgParam("ADDL_FEMALE_FERTILITY_TARGET", F);

    // Resistance phase parameters:
    defineCfgParam("GERMLINE_RESISTANCE_RATE", 0.99);
    defineCfgParam("EMBRYO_RESISTANCE_RATE", 0.05);
    defineCfgParam("LEAKY_SOMATIC_EXPRESSION", F);
    defineCfgParam("R1_OCCURRENCE_RATE", 0.0);

    // Drop parameters:
    defineCfgParam("CAPACITY", 50000);
    defineCfgParam("FRACTION", 0.66);
    defineCfgParam("DROP_RADIUS", 0.38);
    defineCfgParam("DROP_ADDS_TO_POP", F);  // If T, the drop is added to the population, rather than overwriting preexisting individuals.
    defineCfgParam("MUTLIPLE_DROPS", F);
    defineCfgParam("DROP_INTERVAL", 0);  // If multiple drops.
    defineCfgParam("MAX_NUMBER_OF_DROPS", 0);  // No maximum if zero.
    defineCfgParam("MALE_ONLY_DROP", F);
    defineCfgParam("FEMALE_ONLY_DROP", F);
    defineCfgParam("HETEROZYGOUS_DROP", T);

    // Drop types:
    defineCfgParam("CIRCLE_DROP", T);
    defineCfgParam("UNIFORM_DROP", F);
    defineCfgParam("CORNER_DROP", F);
    defineCfgParam("LEFT_EDGE_HEMICIRCLE_DROP", F);
    defineCfgParam("LEFT_EDGE_DROP", F);
    
    // Ecology parameters:
    defineCfgParam("MAX_ATTEMPTS_TO_FIND_SUITABLE_MATE", 9);
    defineCfgParam("LOW_DENSITY_GROWTH_RATE", 6);
    defineCfgParam("MOVEMENT_SPEED", 0.04);
    defineCfgParam("MAX_OFFSPRING", 50);
    defineCfgParam("RATE_FEMALES_SURVIVE", 0.0);  // For partially overlapping generations.
    defineConstant("NUMBER_OF_CELLS", 64); // A perfect-square value- the number of quadrants for Green's coefficient calculation. //ignore

    // Other
    defineCfgParam("ALLOW_EARLY_EXIT", F);
    // */    // End header.

    
    // Toggle from default torroidal space to flat space with reprising boundaries:
    defineCfgParam("REPRISING_BOUNDARIES", T);

    // Globals related to spatial modeling and life cycle.
    defineCfgParam("FEMALE_SPEED", MOVEMENT_SPEED);
    defineCfgParam("MATING_DISTANCE", MOVEMENT_SPEED);
    defineCfgParam("DENSITY_INTERACTION_DISTANCE", 0.02);
    defineCfgParam("INBREEDING_AVOIDANCE_FACTOR", 0.0);

    // For mortality rate as a function of age, for runs with overlaping generations.
    // Some females may be allowed to survive two generations:
    defineConstant("MALE_MORTALITY", c(1.0));
    defineConstant("FEMALE_MORTALITY", c((1.0 - RATE_FEMALES_SURVIVE), 1.0));

    defineConstant("EQUILIBRIUM_WT_ALLELE_THRESHOLD", 0.8*2*CAPACITY);

    // This simulation will use a non-Wright-Fisher model.
    initializeSLiMModelType("nonWF");

    if (REPRISING_BOUNDARIES)
        initializeSLiMOptions(keepPedigrees=T, dimensionality="xy");
    else
        initializeSLiMOptions(keepPedigrees=T, dimensionality="xy", periodicity="xy");

    initializeInteractionType(1, "xy", reciprocal=T, maxDistance=MATING_DISTANCE);
    // Adult competition:
    initializeInteractionType(2, "xy", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
    defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY * PI * DENSITY_INTERACTION_DISTANCE^2);

    // Four variations: Wild type, drive, r1 resistance, r2 resistance.
    // 'cut' is a temporary placeholder, and 'gap' represents a missing segment.
    wt = initializeMutationType("m1", 0.5, "f", 0.0);
    dr = initializeMutationType("m2", 0.5, "f", 0.0);
    r1 = initializeMutationType("m3", 0.5, "f", 0.0);
    r2 = initializeMutationType("m4", 0.5, "f", 0.0);
    d2 = initializeMutationType("m5", 0.5, "f", 0.0);
    variations = c(wt, dr, r1, r2, d2);

    // Variations are all part of g1 genome element.
    initializeGenomicElementType("g1", variations, c(1, 1, 1, 1, 1));

    // Element is NUM_LOCI long, each spot on the element representing a drive location.
    if (ADDL_FEMALE_FERTILITY_TARGET)
        initializeGenomicElement(g1, 0, NUM_LOCI);
    else
        initializeGenomicElement(g1, 0, NUM_LOCI - 1);

    // These variations overwrite one another.
    variations.mutationStackPolicy = "l";
    variations.mutationStackGroup = 1;

    // No mutation in this model.
    initializeMutationRate(0.0);

    // All sites are independent.
    initializeRecombinationRate(0.5);

    // Simulate sexual reproduction: A for autosome.
    initializeSex("A");
}

//// HELPER FUNC FOR CONSTANTS THAT MAY ASLO BE CONFIGURED VIA COMMAND LINE.
function (void) defineCfgParam(string$ name, lifs value) {
    if (!exists(name))
        defineConstant(name, value);
}

//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
    // Resistance alleles form at a specified rate.
    // m3 is R1 allele, m4 is R2.
    if(runif(1) < R1_OCCURRENCE_RATE)
        genome.addNewDrawnMutation(m3, locus);
    else
        genome.addNewDrawnMutation(m4, locus);
}

//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE AND EMBRYO.
function (void)driveResistance(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
    // If parent doesn't have drive allele, nothing happens.
    if (!sum(parent.genomes.countOfMutationsOfType(m2)) & !sum(parent.genomes.countOfMutationsOfType(m5)))
        return;

    // Child must be inheritting wt to cut, or nothing happens.
    if (!child_chromosome.countOfMutationsOfType(m1))
        return;

    // The wt loci the child is inheriting, and the drive loci of the parent:
    wt_loci = child_chromosome.positionsOfMutationsOfType(m1);
    dr_loci = parent.genomes.positionsOfMutationsOfType(m2);

    // With mutual targeting drive, drive at site x targets site x+1. The drive at NUM_LOCI targets site 0.
    if (MUTUAL_TARGETING_DRIVE)
        for (i in seqAlong(wt_loci))
            for (j in seqAlong(dr_loci))
                if (wt_loci[i] == (dr_loci[j] + 1) % NUM_LOCI)
                    if (runif(1) < resistance_rate)
                        addResistanceAllele(child_chromosome, wt_loci[i]);

    // Drive at x causes resistance at wt at x.
    if (SELF_TARGETING_DRIVE)
        for (i in seqAlong(wt_loci))
            for (j in seqAlong(dr_loci))
                if (wt_loci[i] == dr_loci[j])
                    if (runif(1) < resistance_rate)
                        addResistanceAllele(child_chromosome, wt_loci[i]);

    // Drive at site x (x<NUM_LOCI) targets site x+1.
    // There is not drive at NUM_LOCI, and consequently no drive causes resistance at site 0.
    if (SITE_ZERO_NON_TARGETED)
        for (i in seqAlong(wt_loci))
            for (j in seqAlong(dr_loci))
                if (wt_loci[i] == dr_loci[j] + 1)
                    if (runif(1) < resistance_rate)
                        addResistanceAllele(child_chromosome, wt_loci[i]);

    if (DOUBLE_TOXINS) {
        dr2_loci = parent.genomes.positionsOfMutationsOfType(m5);
        for (i in seqAlong(wt_loci)) {
            for (j in seqAlong(dr_loci))
                if (wt_loci[i] == dr_loci[j] + 1)
                    if (runif(1) < resistance_rate)
                        addResistanceAllele(child_chromosome, wt_loci[i]);
            for (j in seqAlong(dr2_loci))
                if (wt_loci[i] == dr2_loci[j] + 2)
                    if (runif(1) < resistance_rate)
                        addResistanceAllele(child_chromosome, wt_loci[i]);
        }
    }

    // Add resistance at locus reserved for an unrescued recessive fertility target.
    if (ADDL_FEMALE_FERTILITY_TARGET)
        if (dr_loci[0] == 0)
            if (runif(1) < resistance_rate)
                addResistanceAllele(child_chromosome, NUM_LOCI);
}

//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
    m1_loci = source.positionsOfMutationsOfType(m1);
    m2_loci = source.positionsOfMutationsOfType(m2);
    m3_loci = source.positionsOfMutationsOfType(m3);
    m4_loci = source.positionsOfMutationsOfType(m4);
    for (i in seqAlong(m1_loci))
        destination.addNewDrawnMutation(m1, m1_loci[i]);
    for (i in seqAlong(m2_loci))
        destination.addNewDrawnMutation(m2, m2_loci[i]);
    for (i in seqAlong(m3_loci))
        destination.addNewDrawnMutation(m3, m3_loci[i]);
    for (i in seqAlong(m4_loci))
        destination.addNewDrawnMutation(m4, m4_loci[i]);
}

//// GENE DRIVE IMPLEMENTATION RULES THAT OCCUR IN EVERY CHILD.
1: modifyChild() {
    // If the drive is x-linked, prevent it from being inherited on Y chromosome:
    if (X_LINKED) {
        if(child.sex == "M")
            copy_genome(parent2Genome2, child.genome2);
        if(child.sex == "F")
            copy_genome(parent2Genome1, child.genome2);
    }

    // Apply effects that happen in the germline.
    if (!MALE_ONLY_PROMOTER)
        driveResistance(childGenome1, parent1, GERMLINE_RESISTANCE_RATE);
    driveResistance(childGenome2, parent2, GERMLINE_RESISTANCE_RATE);

    // Apply effects that happen in the embryo.
    if (!MALE_ONLY_PROMOTER) {
        driveResistance(childGenome1, parent1, EMBRYO_RESISTANCE_RATE);
        driveResistance(childGenome2, parent1, EMBRYO_RESISTANCE_RATE);
    }

    // If the drive is x-linked, prevent gene drive mechanics on Y chromosome by resetting it:
    if (X_LINKED)
        if(child.sex == "M")
            copy_genome(parent2Genome2, child.genome2);

    // Resistance alleles can have the affect of rendering offspring non-viable with many of these systems.
    // With SITE_ZERO_NON_TARGETED systems, two copies of the drive at site zero provides rescue for site at NUM_LOCI.
    c1_res = childGenome1.positionsOfMutationsOfType(m4);
    c2_res = childGenome2.positionsOfMutationsOfType(m4);
    c1_dr = childGenome1.positionsOfMutationsOfType(m2);
    c2_dr = childGenome2.positionsOfMutationsOfType(m2);

    if (ADDL_FEMALE_FERTILITY_TARGET) {
        c1_res = setDifference(c1_res, NUM_LOCI);
        c2_res = setDifference(c2_res, NUM_LOCI);
    }

    if (LEAKY_SOMATIC_EXPRESSION) {
        // Cas9 expression in the embryo results in toxic effect where inherited drive disrupts inherited wt.
        c1_wt = childGenome1.positionsOfMutationsOfType(m1);
        c2_wt = childGenome2.positionsOfMutationsOfType(m1);
        new_c1_res = setIntersection(c2_dr, c1_wt);
        new_c2_res = setIntersection(c1_dr, c2_wt);
        c1_res = setUnion(c1_res, new_c1_res);
        c2_res = setUnion(c2_res, new_c2_res);
    }

    // For systems with multiple toxins possible at a locus.
    if (DOUBLE_TOXINS) {
        c1_dr = c1_dr + 2;  // Drive 1 at site x cuts at site x + 1 and rescues site x + 2.
        c2_dr = c2_dr + 2;
        c1_dr2 = childGenome1.positionsOfMutationsOfType(m5) + 1;  // Drive 2 at site x cuts at site x + 2 and rescues site x + 1.
        c2_dr2 = childGenome2.positionsOfMutationsOfType(m5) + 1;
        if (TADE_LETHAL) {
            double_d1_rescue = setIntersection(c1_dr, c2_dr);
            double_d2_rescue = setIntersection(c1_dr2, c2_dr2);
            double_res = setIntersection(c1_res, c2_res);
            unrescued_double_res = setDifference(setDifference(double_res, double_d1_rescue), double_d2_rescue);
            unrescued_single_c1 = setDifference(setDifference(setDifference(setDifference(c1_res, c1_dr), c1_dr2), c2_dr), c2_dr2);
            unrescued_single_c2 = setDifference(setDifference(setDifference(setDifference(c2_res, c1_dr), c1_dr2), c2_dr), c2_dr2);
            if (size(unrescued_double_res) | size(unrescued_single_c1) | size(unrescued_single_c2))
                return F;
        }
        if (TADDE_LETHAL) {
            combined_res_loci = setUnion(c1_res, c2_res);
            unrescued = setDifference(setDifference(setDifference(setDifference(combined_res_loci, c1_dr), c1_dr2), c2_dr), c2_dr2);
            if (size(unrescued))
                return F;
        }
        if (TARE_LETHAL) {
            double_res = setIntersection(c1_res, c2_res);
            unrescued = setDifference(setDifference(setDifference(setDifference(double_res, c1_dr), c1_dr2), c2_dr), c2_dr2);
            if (size(unrescued))
                return F;
        }
        if (TAHRE_LETHAL) {
            double_res = setIntersection(c1_res, c2_res);
            d1_rescue = setIntersection(c1_dr, c2_dr);
            d2_rescue = setIntersection(c1_dr2, c2_dr2);
            unrescued = setDifference(setDifference(double_res, d1_rescue), d2_rescue);
            if (size(unrescued))
                return F;
        }
    }
    else{
        // If drive is haplolethal offspring not viable if r2 on either chromosome (TADE):
        if (TADE_LETHAL) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count > drive_rescue_count)
                    return F;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            resistance_sites = setUnion(c1_res, c2_res);
            if (size(resistance_sites))
                return F;
        }

        // If drive is recessive lethal, offspring not viable if r2 on matching locations (TARE):
        if (TARE_LETHAL) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count - drive_rescue_count == 2)
                    return F;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            match = setIntersection(c1_res, c2_res);
            if (size(match))
                return F;
        }

        // TADDE is same as TADE, but dr/r at a given spot is viable.
        if (TADDE_LETHAL) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count > 2 * drive_rescue_count)
                    return F;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            diff1 = setDifference(c1_res, c2_dr);
            diff2 = setDifference(c2_res, c1_dr);
            if (size(diff1) | size(diff2))
                return F;
        }

        // TAHRE is the same as TARE but dr/r is non-viable, not just r/r.
        if (TAHRE_LETHAL) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count == 2 & drive_rescue_count != 2)
                    return F;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            res_match = setIntersection(c1_res, c2_res);
            dr_match1 = setIntersection(c1_res, c2_dr);
            dr_match2 = setIntersection(c1_dr, c2_res);
            if (size(res_match) | size(dr_match1) | size(dr_match2))
                return F;
        }
    }
    return T;
}

//// EVALUATE SPATIAL INTERACTIONS BETWEEN INDIVIDUALS FOR OTHER FUNCTIONS.
late() {
    i1.evaluate();
    i2.evaluate();
}

//// SURVIVAL RULES FOR THE SIMULATION BASED ON AGE AND RULES FOR MOVEMENT.
late() {
    all = sim.subpopulations.individuals;
    for (ind in all) {
        ind.age = 0;
        if (ind.sex == "M")
            age_mortality_rate = MALE_MORTALITY[ind.age];
        else
            age_mortality_rate = FEMALE_MORTALITY[ind.age];
        ind.fitnessScaling = 1 - age_mortality_rate;
        // Surviving females now move.
        if (ind.fitnessScaling < 1 & ind.fitnessScaling > 0) {
            if (REPRISING_BOUNDARIES) {
                // Movement within reprising boundaries.
                do position = ind.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
                while (!ind.subpopulation.pointInBounds(position));
                ind.setSpatialPosition(position);
            }
            else {
                // Torroidal world movement.
                ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
                ind.y = ind.y + rnorm(1, 0, FEMALE_SPEED);
                ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
            }
        }
    }
}

//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
    // Representation of the value of the two chromosomes.
    c1_value = 1.0;
    c2_value = 1.0;

    // Check both chromosomes for resistance allele.
    if (ind.genome1.countOfMutationsOfType(m4) > 0)
        c1_value = R2_FITNESS_VALUE;
    if (ind.genome2.countOfMutationsOfType(m4) > 0)
        c2_value = R2_FITNESS_VALUE;

    // Check both chromosomes for drive and type 2 resistance allele.
    c1_dr = ind.genome1.positionsOfMutationsOfType(m2);
    c2_dr = ind.genome2.positionsOfMutationsOfType(m2);
    if (size(c1_dr))
        if (c1_dr[0] == 0)
            c1_value = DRIVE_FITNESS_VALUE;
    if (size(c2_dr))
        if (c2_dr[0] == 0)
            c2_value = DRIVE_FITNESS_VALUE;

    // Check for resistance homozygote and heterozygote fitness penalty in TA*EV drives.
    resistance_fitness_multiplier = 1.0;
    c1_res = ind.genome1.positionsOfMutationsOfType(m4);
    c2_res = ind.genome2.positionsOfMutationsOfType(m4);

    if (ADDL_FEMALE_FERTILITY_TARGET) {
        c1_res = setDifference(c1_res, NUM_LOCI);
        c2_res = setDifference(c2_res, NUM_LOCI);
    }

    if (LEAKY_SOMATIC_EXPRESSION) {
        // Cas9 expression in the embryo results in toxic effect where inherited drive disrupts inherited wt.
        c1_wt = ind.genome1.positionsOfMutationsOfType(m1);
        c2_wt = ind.genome2.positionsOfMutationsOfType(m1);
        new_c1_res = setIntersection(c2_dr, c1_wt);
        new_c2_res = setIntersection(c1_dr, c2_wt);
        c1_res = setUnion(c1_res, new_c1_res);
        c2_res = setUnion(c2_res, new_c2_res);
    }

    // For systems with multiple toxins possible at a locus.
    if (DOUBLE_TOXINS) {
        c1_dr = c1_dr + 2;  // Drive 1 at site x cuts at site x + 1 and rescues site x + 2.
        c2_dr = c2_dr + 2;
        c1_dr2 = ind.genome1.positionsOfMutationsOfType(m5) + 1;  // Drive 2 at site x cuts at site x + 2 and rescues site x + 1.
        c2_dr2 = ind.genome2.positionsOfMutationsOfType(m5) + 1;
        if (TADEV) {
            // Fitness cost being  sqrt(TA_RESISTANCE_FITNESS_MULTIPLIER) where only one copy is missing is not implemented.
            double_d1_rescue = setIntersection(c1_dr, c2_dr);
            double_d2_rescue = setIntersection(c1_dr2, c2_dr2);
            double_res = setIntersection(c1_res, c2_res);
            unrescued_double_res = setDifference(setDifference(double_res, double_d1_rescue), double_d2_rescue);
            unrescued_single_c1 = setDifference(setDifference(setDifference(setDifference(c1_res, c1_dr), c1_dr2), c2_dr), c2_dr2);
            unrescued_single_c2 = setDifference(setDifference(setDifference(setDifference(c2_res, c1_dr), c1_dr2), c2_dr), c2_dr2);
            if (size(unrescued_double_res) | size(unrescued_single_c1) | size(unrescued_single_c2))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
        if (TADDEV) {
            // Fitness cost being  sqrt(TA_RESISTANCE_FITNESS_MULTIPLIER) where only one copy is missing is not implemented.
            combined_res_loci = setUnion(c1_res, c2_res);
            unrescued = setDifference(setDifference(setDifference(setDifference(combined_res_loci, c1_dr), c1_dr2), c2_dr), c2_dr2);
            if (size(unrescued))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
        if (TAREV) {
            double_res = setIntersection(c1_res, c2_res);
            unrescued = setDifference(setDifference(setDifference(setDifference(double_res, c1_dr), c1_dr2), c2_dr), c2_dr2);
            if (size(unrescued))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
        if (TAHREV) {
            double_res = setIntersection(c1_res, c2_res);
            d1_rescue = setIntersection(c1_dr, c2_dr);
            d2_rescue = setIntersection(c1_dr2, c2_dr2);
            unrescued = setDifference(setDifference(double_res, d1_rescue), d2_rescue);
            if (size(unrescued))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
    }

    else {
        if (TADEV) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                res_count = res_count - drive_rescue_count;
                if (res_count == 1)
                    resistance_fitness_multiplier = sqrt(TA_RESISTANCE_FITNESS_MULTIPLIER);
                if (res_count == 2)
                    resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            resistance_sites = setUnion(c1_res, c2_res);
            if (size(resistance_sites))
                resistance_fitness_multiplier = sqrt(TA_RESISTANCE_FITNESS_MULTIPLIER);

            both_missing = setIntersection(c1_res, c2_res);
            if (size(both_missing))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
        // If drive target is recessive, fitness impact from r2 on matching locations (TARE):
        if (TAREV) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count - drive_rescue_count == 2)
                    resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            match = setIntersection(c1_res, c2_res);
            if (size(match))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
        // TADDE is same as TADE, but dr/r at a given spot is not negatively impacted.
        if (TADDEV) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                res_count = res_count - 2 * drive_rescue_count;
                if (res_count == 1)
                    resistance_fitness_multiplier = sqrt(TA_RESISTANCE_FITNESS_MULTIPLIER);
                if (res_count == 2)
                    resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            diff1 = setDifference(c1_res, c2_dr);
            diff2 = setDifference(c2_res, c1_dr);
            if (size(diff1) | size(diff2))
                resistance_fitness_multiplier = sqrt(TA_RESISTANCE_FITNESS_MULTIPLIER);

            both_missing = setIntersection(c1_res, c2_res);
            if (size(both_missing))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
        // TAHRE is the same as TARE but dr/r is negatively impacted, not just r/r.
        if (TAHREV) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count == 2 & drive_rescue_count != 2)
                    resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            res_match = setIntersection(c1_res, c2_res);
            dr_match1 = setIntersection(c1_res, c2_dr);
            dr_match2 = setIntersection(c1_dr, c2_res);
            if (size(res_match) | size(dr_match1) | size(dr_match2))
                resistance_fitness_multiplier = TA_RESISTANCE_FITNESS_MULTIPLIER;
        }
    }
    // Return fitness for individual with this genotype.
    return sqrt(c1_value * c2_value) * resistance_fitness_multiplier;
}

//// FUNCTION FOR EVALUATING INFERTILITY CAUSED BY SUPRESSION DRIVES.
function (logical)isInfertile(o<Individual>$ ind) {
    c1_res = ind.genome1.positionsOfMutationsOfType(m4);
    c2_res = ind.genome2.positionsOfMutationsOfType(m4);
    c1_dr = ind.genome1.positionsOfMutationsOfType(m2);
    c2_dr = ind.genome2.positionsOfMutationsOfType(m2);

    if (ADDL_FEMALE_FERTILITY_TARGET) {
        if (ind.sex == "F") {
            res_on_c1 = F;
            res_on_c2 = F;
            if (size(c1_res))
                if (c1_res[size(c1_res) - 1] == NUM_LOCI)
                    res_on_c1 = T;
            if (size(c2_res))
                if (c2_res[size(c2_res) - 1] == NUM_LOCI)
                    res_on_c2 = T;
            if (res_on_c1 & res_on_c2)
                return T;
        }
        c1_res = setDifference(c1_res, NUM_LOCI);
        c2_res = setDifference(c2_res, NUM_LOCI);
    }

    if (ind.sex == "F") {
        if (SITE_ZERO_RECESSIVE_FEMALE_STERILE) {
            drive_on_c1 = F;
            drive_on_c2 = F;
            if (size(c1_dr))
                if (c1_dr[0] == 0)
                    drive_on_c1 = T;
            if (size(c2_dr))
                if (c2_dr[0] == 0)
                    drive_on_c2 = T;
            if (drive_on_c1 & drive_on_c2)
                return T;
        }

        // If drive resistance targets are haplosterile (sterile TADE):
        if (FEMALE_TADE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count > drive_rescue_count)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }

            resistance_sites = setUnion(c1_res, c2_res);
            if (size(resistance_sites))
                return T;
        }
        // If drive resistance targets are recessive sterile (sterile TARE):
        if (FEMALE_TARE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count - drive_rescue_count == 2)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            match = setIntersection(c1_res, c2_res);
            if (size(match))
                return T;
        }
        // TADDE is same as TADE, but dr/r at a given spot is not supressed:
        if (FEMALE_TADDE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count > 2 * drive_rescue_count)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            diff1 = setDifference(c1_res, c2_dr);
            diff2 = setDifference(c2_res, c1_dr);

            if (size(diff1) | size(diff2))
                return T;
        }
        // TAHRE is the same as TARE but dr/r is supressed, not just r/r.
        if (FEMALE_TAHRE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count == 2 & drive_rescue_count != 2)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            res_match = setIntersection(c1_res, c2_res);
            dr_match1 = setIntersection(c1_res, c2_dr);
            dr_match2 = setIntersection(c1_dr, c2_res);
            if (size(res_match) | size(dr_match1) | size(dr_match2))
                return T;
        }
    }
    else {  // For male infertility:
        // Sterile male technique (non-gene drive)
        if (STERILE_MALE) {
            if (sum(ind.genomes.countOfMutationsOfType(m2)))
                return T;
        }
        if (SITE_ZERO_RECESSIVE_MALE_STERILE) {
            drive_on_c1 = F;
            drive_on_c2 = F;
            if (size(c1_dr))
                if (c1_dr[0] == 0)
                    drive_on_c1 = T;
            if (size(c2_dr))
                if (c2_dr[0] == 0)
                    drive_on_c2 = T;
            if (drive_on_c1 & drive_on_c2)
                return T;
        }
        // If drive resistance targets are haplosterile (sterile TADE):
        if (MALE_TADE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count > drive_rescue_count)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }

            resistance_sites = setUnion(c1_res, c2_res);
            if (size(resistance_sites))
                return T;
        }
        // If drive resistance targets are recessive sterile (sterile TARE):
        if (MALE_TARE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count - drive_rescue_count == 2)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            match = setIntersection(c1_res, c2_res);
            if (size(match))
                return T;
        }
        // TADDE is same as TADE, but dr/r at a given spot is not supressed:
        if (MALE_TADDE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count > 2 * drive_rescue_count)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            diff1 = setDifference(c1_res, c2_dr);
            diff2 = setDifference(c2_res, c1_dr);

            if (size(diff1) | size(diff2))
                return T;
        }
        // TAHRE is the same as TARE but dr/r is supressed, not just r/r.
        if (MALE_TAHRE_STERILE) {
            if (SITE_ZERO_NON_TARGETED) {
                // Drive zero rescues the individual from resistance effects at the furthest site (the site at NUM_LOCI).
                drive_rescue_count = 0;
                if (size(c1_dr))
                    if (c1_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;
                if (size(c2_dr))
                    if (c2_dr[0] == 0)
                        drive_rescue_count = drive_rescue_count + 1;

                res_count = 0;
                if (size(c1_res))
                    if (c1_res[size(c1_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;
                if (size(c2_res))
                    if (c2_res[size(c2_res) - 1] == NUM_LOCI - 1)
                        res_count = res_count + 1;

                if (res_count == 2 & drive_rescue_count != 2)
                    return T;

                // The final resistance site has already been processed.
                // Remove it and process other sites according to the general rules.
                c1_res = setDifference(c1_res, NUM_LOCI - 1);
                c2_res = setDifference(c2_res, NUM_LOCI - 1);
            }
            res_match = setIntersection(c1_res, c2_res);
            dr_match1 = setIntersection(c1_res, c2_dr);
            dr_match2 = setIntersection(c1_dr, c2_res);
            if (size(res_match) | size(dr_match1) | size(dr_match2))
                return T;
        }
    }
    return F;
}

//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(NULL, "F") {
    // First, evaluate whether reproduction is suppressed by a population suppression drive,
    // Then, select a mate based on fitness, then generate offspring.

    // Check to see if this female is infertile because of drive mechanics:
    if (isInfertile(individual))
        return;

    all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
    is_male = (all_neighbors.sex == "M");
    neighbors = all_neighbors[is_male];
    // If no mates are in mate detection range, cannot mate.
    if (size(neighbors) == 0)
        return;

    // Females choose a random provisional mate, but make a final mating decision based on the
    // attractiveness of that mate, as determined by the fitness of the mate. If a mate is
    // rejected, the female tries again, up to a maximum number of tries, after which she gives up.
    attempt_no = 0;
    while (1) {
        // First, select a random mate.
        mate_no = 0;
        if (size(neighbors) > 1)
            mate_no = rdunif(1, max=size(neighbors) - 1);
        selected_mate = neighbors[mate_no];
        // Determine attractiveness of mate.
        mate_attractiveness = genotypeFitness(selected_mate);
        if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
            mate_attractiveness = mate_attractiveness * (1 - INBREEDING_AVOIDANCE_FACTOR);

        // Determine if this mate is chosen, based on attractiveness.
        if (runif(1) < mate_attractiveness)
            break;  // Select this mate.
        // After ten candidates fail, female gives up.
        attempt_no = attempt_no + 1;
        if (attempt_no == MAX_ATTEMPTS_TO_FIND_SUITABLE_MATE)
            return;
    }
    // Mate has now been selected.

    // Check to see if mate is infertile because of drive mechanics.
    if (isInfertile(selected_mate))
        return;

    adult_density_force = i2.totalOfNeighborStrengths(individual);
    competition_ratio = adult_density_force / EXPECTED_ADULT_COMPETITION;

    // Fecundity is based on both the crowding/competition in the system, as well as female fitness.
    // Number of offspring number based on binomial distrobution.
    capacity_fitness_scaling = LOW_DENSITY_GROWTH_RATE / (((LOW_DENSITY_GROWTH_RATE - 1) * competition_ratio) + 1);

    p = genotypeFitness(individual) * capacity_fitness_scaling * 2 / MAX_OFFSPRING / (1 + RATE_FEMALES_SURVIVE);
    num_offspring = rbinom(1, MAX_OFFSPRING, p);

    for (i in seqLen(num_offspring)) {
        // Add offspring to the subpopulation.
        offspring = subpop.addCrossed(individual, selected_mate);
        if (!isNULL(offspring)) {
           if (REPRISING_BOUNDARIES) {
               // Offspring placement within reprising boundaries.
               do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
               while (!individual.subpopulation.pointInBounds(position));
               offspring.setSpatialPosition(position);
            }
            else {
                // Torroidal world offspring placement.
                position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
                offspring.setSpatialPosition(p1.pointPeriodic(position));
            }
        }
    }
}

//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
    all = sim.subpopulations.individuals;
    for (individual in all) {
        individual.color = "blue";
        if (individual.countOfMutationsOfType(m2))
            individual.color = "red";
    }
}

//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 {
    // Start with a population of wild type flies.
    sim.addSubpop("p1", CAPACITY);
    for (i in seqLen(NUM_LOCI))
        p1.individuals.genomes.addNewDrawnMutation(m1, i);
    if (ADDL_FEMALE_FERTILITY_TARGET)
        p1.individuals.genomes.addNewDrawnMutation(m1, NUM_LOCI);
    p1.individuals.x = runif(p1.individualCount);
    p1.individuals.y = runif(p1.individualCount);
}

//// DROP A GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
11: late() {
    if (asInteger(sim.generation) == 11 | (MUTLIPLE_DROPS & ((asInteger(sim.generation) - 11) % DROP_INTERVAL == 0))) {
        if (!MAX_NUMBER_OF_DROPS | asInteger(sim.generation) <= 11 + DROP_INTERVAL * (MAX_NUMBER_OF_DROPS - 1)) {
            if (CIRCLE_DROP) 
                size_of_drop = asInteger(p1.individualCount * PI * DROP_RADIUS^2 * FRACTION);
            else if (LEFT_EDGE_HEMICIRCLE_DROP) 
                size_of_drop = asInteger(p1.individualCount * PI * DROP_RADIUS^2 * FRACTION / 2);
            else if (CORNER_DROP) 
                size_of_drop = asInteger(p1.individualCount * PI * DROP_RADIUS^2 * FRACTION / 4);
            else if (LEFT_EDGE_DROP)
                size_of_drop = asInteger(p1.individualCount * DROP_RADIUS * FRACTION);
            else 
                size_of_drop = asInteger(p1.individualCount * FRACTION);

            // For multiple drops, same amount of drives are added to the population after every interval
            if (UNIFORM_DROP & MUTLIPLE_DROPS & DROP_ADDS_TO_POP)
                size_of_drop = asInteger(CAPACITY * FRACTION);

            all = sim.subpopulations.individuals;
            num_dr = sum(all.genomes.countOfMutationsOfType(m2) + all.genomes.countOfMutationsOfType(m5));
            num_drives = SITE_ZERO_NON_TARGETED ? NUM_LOCI - 1 else DOUBLE_TOXINS ? NUM_LOCI - 2 else NUM_LOCI;
            rate_dr = num_dr / (2 * num_drives * size(all)); //rate of drive alleles

            if (DROP_ADDS_TO_POP & (rate_dr < 0.6)) {
                // Add a drop of modified individuals to p1.
                if (MALE_ONLY_DROP | STERILE_MALE)
                    // Drop a population of only males.
                    sim.addSubpop("p2", size_of_drop, 1.0);
                else if (FEMALE_ONLY_DROP)
                    // Drop a population of only females.
                    sim.addSubpop("p2", size_of_drop, 0.0);
                else
                    sim.addSubpop("p2", size_of_drop);
                drop = p2.individuals;
            }
            else if (DROP_ADDS_TO_POP & (rate_dr >= 0.6)) {
                size_of_drop = 0;
                drop = sample(p1.individuals, size_of_drop);
            }
            else
                drop = sample(p1.individuals, size_of_drop);

            // Now set the drop individuals to the correct genotypes:
            for (i in seqLen(NUM_LOCI))
                drop.genomes.addNewDrawnMutation(m2, i);

            // Systems with two toxins per locus, the last two sites have no drive and c2 gets the second drive.
            if (DOUBLE_TOXINS) {
                for (i in seqLen(NUM_LOCI))
                    drop.genome2.addNewDrawnMutation(m5, i);
                drop.genomes.addNewDrawnMutation(m1, NUM_LOCI - 1);
                drop.genomes.addNewDrawnMutation(m1, NUM_LOCI - 2);
            }

            // For drive systems with a supression drive at locus 0, the final locus has no drive.
            if (SITE_ZERO_NON_TARGETED)
                drop.genomes.addNewDrawnMutation(m1, NUM_LOCI - 1);

            // For heterozygous drop, one of the chromosomes is set to wild type:
            if (HETEROZYGOUS_DROP)
                for (i in seqLen(NUM_LOCI))
                    drop.genome2.addNewDrawnMutation(m1, i);

            // In X_LINKED males' genome2 (from father) is always wt.
            if (X_LINKED) {
                males = (drop.sex == "M");
                // Set all Y chromosomes to wt.
                for (i in seqLen(NUM_LOCI))
                    drop[males].genome2.addNewDrawnMutation(m1, i);
            }

            if (ADDL_FEMALE_FERTILITY_TARGET)
                drop.genomes.addNewDrawnMutation(m1, NUM_LOCI);

            // Now that genes have been set, move all the individuals from the drop into p1:
            p1.takeMigrants(drop);
                
            // For 2-D simulations
            if (LEFT_EDGE_HEMICIRCLE_DROP) {
        		for (ind in drop) {
                    theta = runif(1, -0.5*PI, 0.5*PI);
                    r = sqrt(runif(1, 0, 1)) * DROP_RADIUS;
                    ind.x = r * cos(theta);
                    ind.y = 0.5 + r * sin(theta);
                    ind.color = "red";           
                }
    		} else if (CIRCLE_DROP) { 
    			for (ind in drop) {
                    theta = runif(1, 0, 2 * PI);
                    r = sqrt(runif(1, 0, 1)) * DROP_RADIUS;
                    ind.x = 0.5 + r * cos(theta);
                    ind.y = 0.5 + r * sin(theta);
                    ind.color = "red";           
                }
    		} else if (UNIFORM_DROP) { //Scattered uniformly
    			drop.x = runif(size_of_drop);
    			drop.y = runif(size_of_drop);
    			drop.color = "red";
    		} else if (CORNER_DROP) {
    			for (ind in drop) {
    				theta = runif(1, 0, 0.5 * PI);
                    r = sqrt(runif(1, 0, 1)) * DROP_RADIUS;
                    ind.x = r * cos(theta);
                    ind.y = r * sin(theta); 
                    ind.color = "red";
    				//ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
    			}
    		} else if (LEFT_EDGE_DROP) { // Left-rectangle drop
			    drop.x = runif(size_of_drop, 0, DROP_RADIUS);
			    drop.y = runif(size_of_drop);
                drop.color = "red";
		    } 	   		           
        }
    }


    //// PROGRAM OUTPUT AFTER DROP.
    all = sim.subpopulations.individuals;
    pop_size = length(all);
    this_gen = sim.generation-10;
    num_dr = sum(all.genomes.countOfMutationsOfType(m2) + all.genomes.countOfMutationsOfType(m5));
    num_drives = SITE_ZERO_NON_TARGETED ? NUM_LOCI - 1 else DOUBLE_TOXINS ? NUM_LOCI - 2 else NUM_LOCI;
    rate_dr = num_dr / (2 * num_drives * size(all));
    num_wt = sum(all.genomes.countOfMutationsOfType(m1));
    num_r1 = sum(all.genomes.countOfMutationsOfType(m3));
    num_r2 = sum(all.genomes.countOfMutationsOfType(m4));
    num_has_drive = sum(all.genome1.countOfMutationsOfType(m2) > 0
                      | all.genome2.countOfMutationsOfType(m2) > 0
                      | all.genome1.countOfMutationsOfType(m5) > 0
                      | all.genome2.countOfMutationsOfType(m5) > 0);
    females = all[all.sex=="F"];
    num_females = length(females);
	num_fertile_females = sum(females.countOfMutationsOfType(m1) | females.countOfMutationsOfType(m3));
	catn("FERTILE_FEMALES:: "+num_fertile_females);

    num_wt_loci = NUM_LOCI;
    if (ADDL_FEMALE_FERTILITY_TARGET)
        num_wt_loci = NUM_LOCI + 1;

    rate_wt = num_wt / (2 * num_wt_loci * size(all));
    rate_dr = num_dr / (2 * num_drives * size(all)); //rate of drive alleles
    rate_r1 = num_r1 / (2 * num_drives * size(all));
    rate_r2 = num_r2 / (2 * num_drives * size(all));

    rate_has_drive = num_has_drive / (size(all)); //rate of individuals that carry drives


    // Won't start tracking Green's coefficient until the number of
	// wt alleles falls at least 20% from its equilibrium value.
	sim.setValue("start_gc_tracking", F);
    
    // Chasing analysis:

	// First, check whether the number of wild-type alleles has decreased at least
	// 20% from its equilibrium value	if (SUPPRESSION_OUTPUT) {

	if (num_wt < EQUILIBRIUM_WT_ALLELE_THRESHOLD) {
		catn("POTENTIAL_CHASE:: " + this_gen);

        if (!sim.getValue("start_gc_tracking"))
			sim.setValue("start_gc_tracking", T); // Start measuring Green's coefficient
	}
    // Record quadrant counts to calculate Green's coefficient
	if (sim.getValue("start_gc_tracking")) {
		nondrive = all[all.countOfMutationsOfType(m2) == 0];
		nonx = nondrive.x;
		nony = nondrive.y;
		allx = all.x;
		ally = all.y;
		pos_vec = 0:(sqrt(NUMBER_OF_CELLS) - 1);
		dim = length(pos_vec);
		cell_width = 1.0/dim;
		positions = pos_vec * cell_width;
		nondrive_track = c();
		all_track = c();

		for (i in 0:(dim-1)) {
			div_left = positions[i];
			for (j in 0:(dim-1)) {
				div_bot = positions[j];

				nondrive_in_division = (nonx >= div_left) & (nonx < (div_left + cell_width)) & (nony >= div_bot) & (nony < (div_bot + cell_width));
				nondrive_in_cell = nondrive[nondrive_in_division];
				nondrive_cell_count = size(nondrive_in_cell);
				nondrive_track = c(nondrive_track, nondrive_cell_count);

				all_in_division = (allx >= div_left) & (allx < (div_left + cell_width)) & (ally >= div_bot) & (ally < (div_bot + cell_width));
				all_in_cell = all[all_in_division];
				all_cell_count = size(all_in_cell);
				all_track = c(all_track, all_cell_count);
				}
		}

		nondrive_pop_size = sum(nondrive_track); // Number of wts

		// Prevent nan-error issues
		if (nondrive_pop_size > 1) {
			nondrive_greens_coeff = (var(nondrive_track)/mean(nondrive_track) - 1)/(sum(nondrive_track) - 1);
			all_greens_coeff = (var(all_track)/mean(all_track) - 1)/(sum(all_track)-1);
		// (1) number wt alleles (2) generation (3) population size (5) Green's coefficient of wts for chase detection (7) Green's coefficient of all individuals
			catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + nondrive_greens_coeff + " " + "OVERALL_GC::" + " " + all_greens_coeff);
		}
	}

    //// Conditions that will stop the simulation:

	// 1- The drive was lost and the wt population remained
	if (num_dr == 0 & (pop_size>0)) {
		catn("POP_PERSISTS:: " + this_gen);
		sim.simulationFinished();
	}
	
    // 2- Suppression occurs
	if (pop_size == 0) {
		catn("SUPPRESSED:: " + this_gen);
		sim.simulationFinished();
	}

    // 3- Chasing situation:
    if (this_gen == 1000) {
        catn("LONG_TERM_CHASE:: " + this_gen);
        sim.simulationFinished();
    }

    // Output for humans to look at:
    suppressWarnings(T);
    cat("Rates in " + p1.individualCount + " individuals in generation " + paste(asInteger(sim.generation), "") + ":\n");
    cat("dr: " + rate_dr + "\tr1: " + rate_r1 + "\tr2: " + rate_r2 + "\t%inds with dr: " + rate_has_drive + "\n");
    if (num_dr)
        cat("Number of drive alleles present: " + num_dr + "\n");

    // Calculate expected number of individuals in the next generation (for calcing genetic load in python)
    expected_next_gen_pop_if_no_drive = 2 * sum(all.sex == "F") * (LOW_DENSITY_GROWTH_RATE / (((LOW_DENSITY_GROWTH_RATE - 1) * p1.individualCount / CAPACITY) + 1));

    // Output for processing in python:
    if (size(all))
        cat("PYTHON:: " + paste(asInteger(sim.generation) - 10) + " " + rate_dr + " " + rate_has_drive + " " + 
            rate_r2 + " " + size(all) + "\n\n");

    if (!size(all))
        cat("PYTHON:: " + paste(asInteger(sim.generation) - 10) + " 0 0 0 0\n\n");

    if (ALLOW_EARLY_EXIT)
        // Condition for ending simulation when drive takes over or dies out:
        if ((rate_dr > 0.5 & sim.generation > 22) | (num_has_drive == 0 & sim.generation > 22))
            sim.simulationFinished();

    if (MUTLIPLE_DROPS & ((asInteger(sim.generation) - 11) % DROP_INTERVAL == 0)){
	    if (DROP_ADDS_TO_POP & rate_dr < 0.6){
            p2.removeSubpopulation();
        }
	}

    i1.evaluate();
    i2.evaluate();
}

//// PROGRAM END CONDITION.
1110 late() {
    sim.simulationFinished();
}

//// SET OUTPUT PATH FOR VISUALIZATION FUNCTION:
1 early() {
    if (OUTPUT_SPATIAL_DATA) {
        defineConstant("OUTPUT_PATH", getwd() + "/" + OUTFILE);
        deleteFile(OUTPUT_PATH);
    }
}
//// VISUALIZATION FUNCTION:
late() {
    if (OUTPUT_SPATIAL_DATA) {
        all = sim.subpopulations.individuals;
        output_str = "G";
        for (ind in all) {
            if (ind.color == "")
                ind.color = "blue";
            ind_colors = color2rgb(ind.color);
            hex_x = format("%.3x ", asInteger(ind.x * 4095 + 0.5));
            hex_y = format("%.3x ", asInteger(ind.y * 4095 + 0.5));
            hex_r = format("%.2x ", asInteger(255 * ind_colors[0]));
            hex_g = format("%.2x ", asInteger(255 * ind_colors[1]));
            hex_b = format("%.2x",  asInteger(255 * ind_colors[2]));
            output_str = output_str + "\n" +  hex_x + hex_y + hex_r + hex_g + hex_b;
        }
        writeFile(OUTPUT_PATH, output_str, T);
    }
}

